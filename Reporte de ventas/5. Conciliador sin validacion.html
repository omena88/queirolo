<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asistente de Conciliaci√≥n - Santiago Queirolo</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <style>
    /* Estilos generales de la aplicaci√≥n (similares a Reporte de Ventas) */
    .conciliador-app {
      font-family: 'Inter', sans-serif;
      width: 1200px;
      height: 800px;
      margin: 0 auto;
      padding: 10px;
      display: flex;
      gap: 20px;
    }
    
    .chat-section {
      width: 40%;
      display: flex;
      flex-direction: column;
    }
    
    .actions-section {
      width: 60%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    
    .chat-area {
      flex: 1;
      overflow-y: auto;
      padding: 10px 0;
      margin-bottom: 10px;
    }
    
    .chat-area::-webkit-scrollbar { width: 6px; }
    .chat-area::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
    .chat-area::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
    
    .chat-area p,
    .chat-area div,
    .chat-area span {
      margin-bottom: 0 !important;
      line-height: 1.3 !important;
    }
    
    .typing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #9CA3AF;
      animation: typing 1.4s infinite ease-in-out;
    }
    
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes typing {
      0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .conciliador-app select.select-arrow {
      color: #111827 !important;
      background-color: #ffffff !important;
      border: 2px solid #e5e7eb !important;
      border-radius: 0.5rem !important;
      padding: 0.75rem 2.5rem 0.75rem 1rem !important;
      font-size: 0.875rem !important;
      line-height: 1.25rem !important;
      height: auto !important;
      min-height: 44px !important;
      -webkit-appearance: none !important;
      appearance: none !important;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
      background-position: right 0.75rem center !important;
      background-repeat: no-repeat !important;
      background-size: 1.25em 1.25em !important;
    }

    .conciliador-app select.select-arrow:focus {
      border-color: #3b82f6 !important;
      box-shadow: 0 0 0 3px rgba(59,130,246,.25) !important;
      outline: none !important;
    }

    .conciliador-app select.select-arrow[data-has-value="false"] {
      color: #9CA3AF !important;
    }

    .hidden {
      display: none;
    }
    
    @media (max-width: 1200px) {
      .conciliador-app {
        width: 100%;
        flex-direction: column;
        height: auto;
      }
      .chat-section, .actions-section { width: 100%; }
      .chat-section { height: 300px; }
    }
  </style>
</head>
<body>
  <div class="conciliador-app">
    <!-- Secci√≥n del Chat -->
    <div class="chat-section">
      <div id="chat-messages" class="chat-area space-y-4">
        <!-- Los mensajes aparecer√°n aqu√≠ -->
      </div>
    </div>

    <!-- Secci√≥n de Acciones -->
    <div class="actions-section">
      <div id="input-area" class="hidden">
      
      <!-- Paso 1: Selecci√≥n de Moneda -->
      <div id="step-1" class="p-5 bg-white rounded-xl shadow-lg border border-gray-200">
        <div class="grid grid-cols-2 gap-4 items-end">
          <select id="currency-selector" class="select-arrow py-4 px-4 pe-9 block w-full border-gray-200 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500" data-has-value="false">
            <option value="">Seleccionar moneda</option>
            <option value="PEN">PEN</option>
            <option value="USD">USD</option>
          </select>
          <button id="continue-step-1" class="py-4 px-6 w-full text-sm font-semibold rounded-lg border border-transparent text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:pointer-events-none transition-all duration-200" disabled>
            Continuar
          </button>
        </div>
      </div>

      <!-- Paso 2: Carga de archivo -->
      <div id="step-2" class="p-5 bg-white rounded-xl shadow-lg border border-gray-200 hidden">
        <div id="upload-area" class="p-4 text-center border-2 border-dashed border-orange-300 rounded-xl bg-orange-50 hover:bg-orange-100 transition-colors duration-200 mb-3">
          <div class="mb-2">
            <i class="fas fa-file-invoice text-2xl text-orange-400 mb-2"></i>
            <p id="upload-title" class="text-sm font-medium text-orange-700">Arrastra el extracto EECC aqu√≠</p>
          </div>
          <input type="file" id="file-input" accept=".xlsx,.xls" class="hidden">
        </div>
        <div id="file-display-container"></div>
        <div class="flex justify-end gap-4 mt-4">
          <button id="continue-step-2" class="py-3 px-6 inline-flex items-center gap-x-2 text-sm font-semibold rounded-lg border border-transparent text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:pointer-events-none transition-all duration-200" disabled>
            Continuar
          </button>
        </div>
      </div>

      <!-- Paso 3: Carga de archivos de conciliaci√≥n -->
      <div id="step-3" class="p-5 bg-white rounded-xl shadow-lg border border-gray-200 hidden">
        <div class="space-y-4">
          <!-- AMEX Section -->
          <div class="grid grid-cols-2 gap-4">
            <div id="amex-upload-area" class="p-4 text-center border-2 border-dashed border-blue-300 rounded-xl bg-blue-50 hover:bg-blue-100 transition-colors duration-200 flex flex-col justify-center items-center h-24">
              <i class="fas fa-file-invoice-dollar text-2xl text-blue-400 mb-2"></i>
              <p class="text-sm font-medium text-blue-700">Arrastra archivos AMEX</p>
            </div>
            <div id="amex-file-list" class="space-y-1 max-h-24 overflow-y-auto pr-2"></div>
          </div>
          <!-- DINERS Section -->
          <div class="grid grid-cols-2 gap-4">
            <div id="diners-upload-area" class="p-4 text-center border-2 border-dashed border-green-300 rounded-xl bg-green-50 hover:bg-green-100 transition-colors duration-200 flex flex-col justify-center items-center h-24">
              <i class="fas fa-credit-card text-2xl text-green-400 mb-2"></i>
              <p class="text-sm font-medium text-green-700">Arrastra archivos DINERS</p>
            </div>
            <div id="diners-file-list" class="space-y-1 max-h-24 overflow-y-auto pr-2"></div>
          </div>
          <!-- MC Section -->
          <div class="grid grid-cols-2 gap-4">
            <div id="mc-upload-area" class="p-4 text-center border-2 border-dashed border-red-300 rounded-xl bg-red-50 hover:bg-red-100 transition-colors duration-200 flex flex-col justify-center items-center h-24">
              <i class="fab fa-cc-mastercard text-2xl text-red-400 mb-2"></i>
              <p class="text-sm font-medium text-red-700">Arrastra archivos MC</p>
            </div>
            <div id="mc-file-list" class="space-y-1 max-h-24 overflow-y-auto pr-2"></div>
          </div>
          <!-- VISA Section -->
          <div class="grid grid-cols-2 gap-4">
            <div id="visa-upload-area" class="p-4 text-center border-2 border-dashed border-purple-300 rounded-xl bg-purple-50 hover:bg-purple-100 transition-colors duration-200 flex flex-col justify-center items-center h-24">
              <i class="fab fa-cc-visa text-2xl text-purple-400 mb-2"></i>
              <p class="text-sm font-medium text-purple-700">Arrastra archivos VISA</p>
            </div>
            <div id="visa-file-list" class="space-y-1 max-h-24 overflow-y-auto pr-2"></div>
          </div>
          <!-- PAYU Section (solo para USD) -->
          <div id="payu-section" class="grid grid-cols-2 gap-4 hidden">
            <div id="payu-upload-area" class="p-4 text-center border-2 border-dashed border-yellow-300 rounded-xl bg-yellow-50 hover:bg-yellow-100 transition-colors duration-200 flex flex-col justify-center items-center h-24">
              <i class="fas fa-money-bill-wave text-2xl text-yellow-400 mb-2"></i>
              <p class="text-sm font-medium text-yellow-700">Arrastra archivos PAYU</p>
            </div>
            <div id="payu-file-list" class="space-y-1 max-h-24 overflow-y-auto pr-2"></div>
          </div>
        </div>

        <div class="flex justify-end gap-4 mt-6">
          <button id="continue-step-3" class="py-3 px-6 inline-flex items-center gap-x-2 text-sm font-semibold rounded-lg border border-transparent text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:pointer-events-none transition-all duration-200" disabled>
            Conciliar todo
          </button>
        </div>
      </div>

      <!-- Paso 4: Procesamiento -->
      <div id="step-4" class="p-6 bg-white rounded-xl shadow-lg border border-gray-200 hidden">
        <div class="text-center">
          <div class="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-4">
            <i class="fas fa-cog text-white text-2xl animate-spin"></i>
          </div>
          <h3 class="text-xl font-semibold text-gray-900 mb-4">Procesando conciliaci√≥n...</h3>
          <p class="text-gray-600 mb-6">Estoy analizando los extractos y aplicando las reglas.</p>
        </div>
      </div>

      <!-- Paso 5: Descarga -->
      <div id="step-5" class="p-6 bg-white rounded-xl shadow-lg border border-gray-200 hidden">
        <div class="text-center">
          <div class="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <i class="fas fa-check text-green-600 text-2xl"></i>
          </div>
          <h3 class="text-xl font-semibold text-gray-900 mb-4">¬°Conciliaci√≥n lista!</h3>
          <p class="text-gray-600 mb-6">Tu archivo de extracto ha sido generado.</p>
          <button id="download-excel" class="py-4 px-8 inline-flex items-center gap-x-2 text-base font-semibold rounded-lg border border-transparent text-white bg-green-600 hover:bg-green-700 transition-all duration-200">
            <i class="fas fa-download"></i>
            Descargar Excel
          </button>
        </div>
      </div>

      </div>
    </div>
  </div>



  <!-- Secci√≥n de Cache de Archivos -->
  <div id="cache-section" class="mt-8 p-6 bg-white rounded-xl shadow-lg border border-gray-200 hidden">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-lg font-semibold text-gray-900 flex items-center gap-2">
        <i class="fas fa-database text-blue-600"></i>
        Archivos en Cache
      </h3>
      <div class="flex gap-2">
        <button onclick="updateCacheUI()" class="px-3 py-2 bg-blue-500 text-white rounded-lg text-sm hover:bg-blue-600 transition-colors">
          <i class="fas fa-sync-alt mr-1"></i>
          Actualizar
        </button>
        <button onclick="clearAllCache()" class="px-3 py-2 bg-red-500 text-white rounded-lg text-sm hover:bg-red-600 transition-colors">
          <i class="fas fa-trash-alt mr-1"></i>
          Limpiar Cache
        </button>
      </div>
    </div>
    <div id="cache-files-container" class="space-y-2">
      <!-- Los archivos en cache aparecer√°n aqu√≠ -->
    </div>
  </div>

  <script>

    document.addEventListener('DOMContentLoaded', function() {
      // --- STATE MANAGEMENT ---
      let currentStep = 1;
      let selectedCurrency = null;

      // --- CACHE FUNCTIONS (within DOMContentLoaded scope) ---
      function saveFileToCache(file, type) {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            const fileData = {
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified,
              data: e.target.result,
              cacheType: type,
              timestamp: new Date().toISOString()
            };

            const cacheKey = `conciliador_cache_${type}_${file.name}`;
            localStorage.setItem(cacheKey, JSON.stringify(fileData));

            // console.log(`üíæ Archivo guardado en cache: ${file.name} (${type})`);
            updateCacheUI();
          };
          reader.readAsDataURL(file);
        } catch (error) {
          console.error('Error guardando archivo en cache:', error);
        }
      }

      function savePENFileToCache(file) {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            const fileData = {
              name: file.name,
              size: file.size,
              type: file.type,
              lastModified: file.lastModified,
              data: e.target.result,
              cacheType: 'extracto',
              currency: selectedCurrency,
              isPENFile: selectedCurrency === 'PEN',
              timestamp: new Date().toISOString(),
              fileCategory: selectedCurrency === 'PEN' ? 'PEN_EXTRACTO' : 'OTHER_EXTRACTO'
            };

            const cacheKey = `pen_cache_${selectedCurrency}_${file.name}_${Date.now()}`;
            localStorage.setItem(cacheKey, JSON.stringify(fileData));

            // console.log(`üíæ Archivo PEN guardado en cache: ${file.name} (${selectedCurrency})`);
            updateCacheUI();

            if (selectedCurrency === 'PEN') {
              addBotMessage(`üíæ Archivo PEN guardado en cache para futuras pruebas: ${file.name}`);
            }
          };
          reader.readAsDataURL(file);
        } catch (error) {
          console.error('Error guardando archivo PEN en cache:', error);
        }
      }

      function loadFileFromCache(cacheKey) {
        try {
          const cachedData = localStorage.getItem(cacheKey);
          if (!cachedData) return null;

          const fileData = JSON.parse(cachedData);
          const response = fetch(fileData.data);
          return response.then(res => res.blob()).then(blob => {
            return new File([blob], fileData.name, {
              type: fileData.type,
              lastModified: fileData.lastModified
            });
          });
        } catch (error) {
          console.error('Error cargando archivo desde cache:', error);
          return null;
        }
      }

      function getCachedFiles() {
        const cachedFiles = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('conciliador_cache_')) {
            try {
              const fileData = JSON.parse(localStorage.getItem(key));
              cachedFiles.push({
                key: key,
                ...fileData
              });
            } catch (error) {
              console.error('Error parseando archivo en cache:', error);
            }
          }
        }
        return cachedFiles.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      }

      function getPENFilesFromCache() {
        const cachedFiles = getCachedFiles();
        return cachedFiles.filter(file => {
          const fileName = file.name.toLowerCase();
          const isPENFile = file.isPENFile ||
                           (fileName.includes('eec') && fileName.includes('pen')) ||
                           (file.currency === 'PEN') ||
                           (file.fileCategory === 'PEN_EXTRACTO');

          return file.cacheType === 'extracto' && isPENFile;
        });
      }

      function clearCache() {
        const cacheKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('conciliador_cache_')) {
            cacheKeys.push(key);
          }
        }

        cacheKeys.forEach(key => localStorage.removeItem(key));
        // console.log(`üóëÔ∏è Cache limpiada: ${cacheKeys.length} archivos eliminados`);
        updateCacheUI();
        addBotMessage(`üóëÔ∏è Cache limpiada: ${cacheKeys.length} archivos eliminados`);
      }

      function updateCacheUI() {
        const cachedFiles = getCachedFiles();
        const cacheContainer = document.getElementById('cache-files-container');

        if (!cacheContainer) return;

        if (cachedFiles.length === 0) {
          cacheContainer.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No hay archivos en cache</p>';
          return;
        }

        const penFiles = getPENFilesFromCache();
        const filesByType = cachedFiles.reduce((acc, file) => {
          if (!acc[file.cacheType]) acc[file.cacheType] = [];
          acc[file.cacheType].push(file);
          return acc;
        }, {});

        let html = '';

        if (penFiles.length > 0 && selectedCurrency === 'PEN') {
          html += `
            <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
              <div class="flex items-center justify-between mb-3">
                <h4 class="font-semibold text-blue-800 flex items-center gap-2">
                  <i class="fas fa-star text-blue-600"></i>
                  Archivos PEN Disponibles
                </h4>
                <button onclick="loadLatestPENFile()" class="px-3 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
                  <i class="fas fa-bolt mr-1"></i>
                  Cargar M√°s Reciente
                </button>
              </div>
          `;

          penFiles.forEach(file => {
            const sizeKB = (file.size / 1024).toFixed(1);
            const date = new Date(file.timestamp).toLocaleDateString('es-ES');
            const time = new Date(file.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

            html += `
              <div class="flex items-center justify-between p-3 bg-blue-100 border border-blue-200 rounded text-sm mb-2">
                <div class="flex-1 min-w-0">
                  <span class="font-semibold text-blue-900 truncate block">${file.name}</span>
                  <span class="text-blue-700 text-xs">${date} ${time} ‚Ä¢ ${sizeKB} KB</span>
                </div>
                <div class="flex gap-2 ml-2">
                  <button onclick="loadFromCache('${file.key}')" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
                    <i class="fas fa-upload mr-1"></i>
                    Cargar
                  </button>
                  <button onclick="deleteFromCache('${file.key}')" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                    <i class="fas fa-trash mr-1"></i>
                    Eliminar
                  </button>
                </div>
              </div>
            `;
          });

          html += '</div>';
        }

        Object.keys(filesByType).forEach(type => {
          if (type === 'extracto' && selectedCurrency === 'PEN') {
            const nonPENFiles = filesByType[type].filter(file => !getPENFilesFromCache().some(penFile => penFile.key === file.key));
            if (nonPENFiles.length === 0) return;
            filesByType[type] = nonPENFiles;
          }

          if (filesByType[type].length === 0) return;

          html += `<div class="mb-4"><h4 class="font-medium text-gray-800 mb-2 capitalize">${type}</h4>`;
          filesByType[type].forEach(file => {
            const sizeKB = (file.size / 1024).toFixed(1);
            const date = new Date(file.timestamp).toLocaleDateString('es-ES');
            html += `
              <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-sm mb-1">
                <div class="flex-1 min-w-0">
                  <span class="font-medium text-gray-800 truncate block">${file.name}</span>
                  <span class="text-gray-500 text-xs">${date} ‚Ä¢ ${sizeKB} KB</span>
                </div>
                <div class="flex gap-2 ml-2">
                  <button onclick="loadFromCache('${file.key}')" class="px-2 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600">
                    Cargar
                  </button>
                  <button onclick="deleteFromCache('${file.key}')" class="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600">
                    üóëÔ∏è
                  </button>
                </div>
              </div>
            `;
          });
          html += '</div>';
        });

        cacheContainer.innerHTML = html;
      }

      function loadCachedPENFiles() {
        if (selectedCurrency !== 'PEN') {
          // console.log('No es modo PEN, omitiendo carga autom√°tica');
          return;
        }

        const cachedFiles = getCachedFiles();
        const penFiles = cachedFiles.filter(file => {
          const fileName = file.name.toLowerCase();
          const isPENFile = file.isPENFile ||
                           (fileName.includes('eec') && fileName.includes('pen')) ||
                           (file.currency === 'PEN') ||
                           (file.fileCategory === 'PEN_EXTRACTO');

          return file.cacheType === 'extracto' && isPENFile;
        });

        // console.log(`Encontrados ${penFiles.length} archivos PEN en cache:`, penFiles.map(f => f.name));

        if (penFiles.length > 0) {
          addBotMessage(`üìÇ Encontrados ${penFiles.length} archivos PEN en cache disponibles para pruebas.`);

          if (penFiles.length === 1) {
            const latestFile = penFiles[0];
            loadFileFromCache(latestFile.key).then(file => {
              if (file) {
                uploadedFile = file;
                displayUploadedFile(file);
                document.getElementById('continue-step-2').disabled = false;
                addBotMessage(`‚úÖ Archivo PEN cargado autom√°ticamente desde cache: ${file.name}`);
              }
            }).catch(error => {
              console.error('Error cargando archivo PEN desde cache:', error);
              addBotMessage('‚ùå Error cargando archivo PEN desde cache');
            });
          } else {
            addBotMessage(`üìÇ M√∫ltiples archivos PEN encontrados. El m√°s reciente es: ${penFiles[0].name}`);
          }
        } else {
          // console.log('No se encontraron archivos PEN en cache');
        }
      }

      // Funciones globales para usar desde HTML
      window.loadFromCache = async function(cacheKey) {
        try {
          const file = await loadFileFromCache(cacheKey);
          if (file) {
            const fileData = JSON.parse(localStorage.getItem(cacheKey));
            const type = fileData.cacheType;

            addBotMessage(`üìÅ Cargando desde cache: ${file.name}`);

            switch(type) {
              case 'extracto':
                uploadedFile = file;
                displayUploadedFile(file);
                document.getElementById('continue-step-2').disabled = false;
                break;
              case 'amex':
                handleAmexUpload([file]);
                break;
              case 'diners':
                handleDinersUpload([file]);
                break;
              case 'mc':
                handleMcUpload([file]);
                break;
              case 'visa':
                handleVisaUpload([file]);
                break;
              case 'payu':
                handlePayuUpload([file]);
                break;
            }
          }
        } catch (error) {
          console.error('Error cargando desde cache:', error);
          addBotMessage('‚ùå Error cargando archivo desde cache');
        }
      };

      window.deleteFromCache = function(cacheKey) {
        localStorage.removeItem(cacheKey);
        updateCacheUI();
        addBotMessage('üóëÔ∏è Archivo eliminado de cache');
      };

      window.clearAllCache = function() {
        if (confirm('¬øEst√°s seguro de que quieres limpiar toda la cache? Esta acci√≥n no se puede deshacer.')) {
          clearCache();
        }
      };

      window.loadLatestPENFile = function() {
        const penFiles = getPENFilesFromCache();
        if (penFiles.length > 0) {
          const latestFile = penFiles[0];
          loadFromCache(latestFile.key);
        } else {
          addBotMessage('‚ùå No hay archivos PEN disponibles en cache');
        }
      };
      let uploadedFile = null;
      let amexFiles = [];
      let dinersFiles = [];
      let mcFiles = [];
      let visaFiles = [];
      let payuFiles = [];
      let processedData = { extracto: [], amex: [], diners: [], mc: [], visa: [], payu: [] };

      // --- INITIALIZATION ---
      // console.log('üöÄ Asistente de Conciliaci√≥n iniciado');

      setTimeout(() => {
        showTypingIndicator();
        setTimeout(() => {
          hideTypingIndicator();
          addBotMessage('¬°Hola! üëã Soy tu Asistente de Conciliaci√≥n. Para empezar, por favor, selecciona una moneda.');
          setTimeout(() => {
            showStep(1);
            setupEventListeners();
            // Inicializar UI de cache despu√©s de configurar los event listeners
            updateCacheUI();

            // Intentar cargar archivos PEN autom√°ticamente si estamos en modo PEN
            setTimeout(() => {
              if (selectedCurrency === 'PEN') {
                loadCachedPENFiles();
              }
            }, 1000);
          }, 800);
        }, 1000);
      }, 500);

      // --- EVENT LISTENERS ---
      function setupEventListeners() {
        // Step 1: Currency selection
        const currencySelector = document.getElementById('currency-selector');
        const continueStep1Btn = document.getElementById('continue-step-1');

        currencySelector.addEventListener('change', (e) => {
          e.target.dataset.hasValue = !!e.target.value;
          selectedCurrency = e.target.value;
          continueStep1Btn.disabled = !selectedCurrency;

          // Si se selecciona PEN, intentar cargar archivos desde cache autom√°ticamente
          if (selectedCurrency === 'PEN') {
            setTimeout(() => {
              loadCachedPENFiles();
            }, 500);
          }
        });

        continueStep1Btn.addEventListener('click', goToStep2);

        // Step 2: File upload & Drag and Drop
        const fileInput = document.getElementById('file-input');
        const continueStep2Btn = document.getElementById('continue-step-2');
        const uploadArea = document.getElementById('upload-area');
        
        fileInput.addEventListener('change', (e) => handleFileUpload(e.target.files[0]));
        
        const fileDisplayContainer = document.getElementById('file-display-container');

        // --- FILE HANDLING & UI LOGIC ---

        function displayUploadedFile(file) {
          const fileDisplayContainer = document.getElementById('file-display-container');
          fileDisplayContainer.innerHTML = `
            <div class="p-1 bg-orange-50 border border-orange-200 rounded text-xs flex items-center justify-between mt-2">
              <div class="flex items-center gap-2 flex-1 min-w-0">
                <i class="fas fa-file-excel text-orange-600 text-xs"></i>
                <span class="font-medium text-orange-900 truncate">${file.name}</span>
              </div>
              <button onclick="removeFile()" class="p-1 text-red-500 hover:text-red-700">
                <i class="fas fa-times text-xs"></i>
              </button>
            </div>`;
          fileDisplayContainer.classList.remove('hidden');
          document.getElementById('continue-step-2').disabled = false;
        }

        window.removeFile = function() {
          uploadedFile = null;
          document.getElementById('file-input').value = '';
          const fileDisplayContainer = document.getElementById('file-display-container');
          fileDisplayContainer.innerHTML = '';
          fileDisplayContainer.classList.add('hidden');
          document.getElementById('continue-step-2').disabled = true;
          // console.log('Archivo de extracto eliminado');
        }

        function handleFileUpload(file) {
          if (!file) return;

          uploadedFile = file;
          // console.log('Archivo cargado:', uploadedFile.name);

          // Guardar en cache autom√°ticamente (con funci√≥n especial para PEN)
          if (selectedCurrency === 'PEN') {
            savePENFileToCache(file);
          } else {
            saveFileToCache(file, 'extracto');
          }

          displayUploadedFile(file);
        }

        // Drag and Drop listeners
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('border-blue-500', 'bg-blue-50');
        });

        uploadArea.addEventListener('dragleave', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('border-blue-500', 'bg-blue-50');
        });

        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('border-blue-500', 'bg-blue-50');
          const files = Array.from(e.dataTransfer.files);
          if (files.length > 0) {
            fileInput.files = e.dataTransfer.files;
            handleFileUpload(files[0]);
          }
        });

        continueStep2Btn.addEventListener('click', goToStep3);
        
        // Step 3: AMEX and DINERS Files
        const amexFileInput = document.getElementById('amex-file-input');
        const amexUploadArea = document.getElementById('amex-upload-area');
        const dinersFileInput = document.getElementById('diners-file-input');
        const dinersUploadArea = document.getElementById('diners-upload-area');
        const mcFileInput = document.getElementById('mc-file-input');
        const mcUploadArea = document.getElementById('mc-upload-area');
        const visaUploadArea = document.getElementById('visa-upload-area');
        const reconcileBtn = document.getElementById('continue-step-3');

        // AMEX handlers - solo drag and drop
        amexUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            amexUploadArea.classList.add('border-blue-500', 'bg-blue-200');
        });

        amexUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            amexUploadArea.classList.remove('border-blue-500', 'bg-blue-200');
        });

        amexUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            amexUploadArea.classList.remove('border-blue-500', 'bg-blue-200');
            handleAmexUpload(Array.from(e.dataTransfer.files));
        });

        // DINERS handlers - solo drag and drop
        dinersUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dinersUploadArea.classList.add('border-green-500', 'bg-green-200');
        });

        dinersUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dinersUploadArea.classList.remove('border-green-500', 'bg-green-200');
        });

        dinersUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dinersUploadArea.classList.remove('border-green-500', 'bg-green-200');
            handleDinersUpload(Array.from(e.dataTransfer.files));
        });

        // MC handlers - solo drag and drop
        mcUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            mcUploadArea.classList.add('border-red-500', 'bg-red-200');
        });

        mcUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            mcUploadArea.classList.remove('border-red-500', 'bg-red-200');
        });

        mcUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            mcUploadArea.classList.remove('border-red-500', 'bg-red-200');
            handleMcUpload(Array.from(e.dataTransfer.files));
        });

        // VISA handlers
        visaUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            visaUploadArea.classList.add('border-purple-500', 'bg-purple-200');
        });

        visaUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            visaUploadArea.classList.remove('border-purple-500', 'bg-purple-200');
        });

        visaUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            visaUploadArea.classList.remove('border-purple-500', 'bg-purple-200');
            handleVisaUpload(Array.from(e.dataTransfer.files));
        });

        // PAYU handlers
        const payuUploadArea = document.getElementById('payu-upload-area');
        payuUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            payuUploadArea.classList.add('border-yellow-500', 'bg-yellow-200');
        });

        payuUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            payuUploadArea.classList.remove('border-yellow-500', 'bg-yellow-200');
        });

        payuUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            payuUploadArea.classList.remove('border-yellow-500', 'bg-yellow-200');
            handlePayuUpload(Array.from(e.dataTransfer.files));
        });

        reconcileBtn.addEventListener('click', () => {
          goToStep4();
        });

        // Step 5: Download
        const downloadBtn = document.getElementById('download-excel');
        downloadBtn.addEventListener('click', generateAndDownloadExcel);
      }

      // --- CHAT UI FUNCTIONS ---
      function showTypingIndicator() {
        const chatMessages = document.getElementById('chat-messages');
        const typingDiv = document.createElement('div');
        typingDiv.id = 'typing-indicator';
        typingDiv.className = 'flex items-start gap-3 fade-in';
        typingDiv.innerHTML = `
          <div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0">
            <i class="fas fa-robot text-white text-sm"></i>
          </div>
          <div class="bg-gray-100 rounded-lg rounded-tl-none p-4 max-w-md">
            <div class="typing-indicator">
              <div class="typing-dot"></div>
              <div class="typing-dot"></div>
              <div class="typing-dot"></div>
            </div>
          </div>`;
        chatMessages.appendChild(typingDiv);
        scrollToBottom();
      }

      function hideTypingIndicator() {
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) typingIndicator.remove();
      }

      function addBotMessage(message) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'flex items-start gap-3 fade-in';
        messageDiv.innerHTML = `
          <div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0">
            <i class="fas fa-robot text-white text-sm"></i>
          </div>
          <div class="bg-gray-100 rounded-lg rounded-tl-none p-4 max-w-md">
            <p class="text-gray-800">${message}</p>
          </div>`;
        chatMessages.appendChild(messageDiv);
        scrollToBottom();
      }

      function scrollToBottom() {
        const chatMessages = document.getElementById('chat-messages');
        setTimeout(() => chatMessages.scrollTop = chatMessages.scrollHeight, 100);
      }
      
      // --- STEP NAVIGATION ---
      function showStep(stepNumber) {
        // console.log(`üëÅÔ∏è Mostrando paso ${stepNumber}`);
        for (let i = 1; i <= 5; i++) {
          const stepEl = document.getElementById(`step-${i}`);
          if (stepEl) stepEl.classList.add('hidden');
        }
        document.getElementById('input-area').classList.remove('hidden');
        const stepEl = document.getElementById(`step-${stepNumber}`);
        stepEl.classList.remove('hidden');
        stepEl.classList.add('fade-in');
        currentStep = stepNumber;
      }

      function goToStep2() {
        addBotMessage(`Perfecto, has seleccionado ${selectedCurrency}. Ahora, por favor carga el archivo de extracto principal.`);
        showStep(2);
      }

      function goToStep3() {
        addBotMessage(`Extracto principal cargado: ${uploadedFile.name}. Ahora, por favor, carga los archivos de conciliaci√≥n.`);
        showStep(3);
        
        // Mostrar/ocultar secci√≥n PAYU seg√∫n la moneda
        const payuSection = document.getElementById('payu-section');
        if (selectedCurrency === 'USD') {
          payuSection.classList.remove('hidden');
        } else {
          payuSection.classList.add('hidden');
        }
      }

      function goToStep4() {
        addBotMessage(`Iniciando proceso de conciliaci√≥n con ${amexFiles.length} archivo(s) AMEX.`);
        showStep(4);
        // Simular procesamiento
        setTimeout(() => {
          processFile();
        }, 2000);
      }

      function goToStep5() {
        addBotMessage(`¬°Proceso completado! Tu archivo con el extracto y AMEX conciliados est√° listo para descargar.`);
        showStep(5);
      }

      // --- FILE HANDLING ---
      function handleAmexUpload(files) {
        const fileList = document.getElementById('amex-file-list');
        updateContinueButton();

        files.forEach(file => {
          if (amexFiles.some(f => f.name === file.name)) {
            addBotMessage(`‚ö†Ô∏è El archivo "${file.name}" ya fue cargado.`);
            return;
          }

          amexFiles.push(file);
          saveFileToCache(file, 'amex');

          const fileDiv = document.createElement('div');
          fileDiv.id = `amex-file-${file.name}`;
          fileDiv.className = 'p-1 bg-blue-50 border border-blue-200 rounded text-xs flex items-center justify-between';
          fileDiv.innerHTML = `
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <i class="fas fa-file-excel text-blue-600 text-xs"></i>
              <span class="font-medium text-blue-900 truncate">${file.name}</span>
            </div>
            <button class="p-1 text-red-500 hover:text-red-700" onclick="removeAmexFile('${file.name}')">
              <i class="fas fa-times text-xs"></i>
            </button>`;
          fileList.appendChild(fileDiv);
        });

        updateContinueButton();
      }

      function handleDinersUpload(files) {
        const fileList = document.getElementById('diners-file-list');
        
        files.forEach(file => {
          if (dinersFiles.some(f => f.name === file.name)) {
            addBotMessage(`‚ö†Ô∏è El archivo "${file.name}" ya fue cargado.`);
            return;
          }

          dinersFiles.push(file);
          saveFileToCache(file, 'diners');

          const fileDiv = document.createElement('div');
          fileDiv.id = `diners-file-${file.name}`;
          fileDiv.className = 'p-1 bg-green-50 border border-green-200 rounded text-xs flex items-center justify-between';
          fileDiv.innerHTML = `
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <i class="fas fa-file-excel text-green-600 text-xs"></i>
              <span class="font-medium text-green-900 truncate">${file.name}</span>
            </div>
            <button class="p-1 text-red-500 hover:text-red-700" onclick="removeDinersFile('${file.name}')">
              <i class="fas fa-times text-xs"></i>
            </button>`;
          fileList.appendChild(fileDiv);
        });

        updateContinueButton();
      }

      function handleMcUpload(files) {
        const fileList = document.getElementById('mc-file-list');
        
        files.forEach(file => {
          if (mcFiles.some(f => f.name === file.name)) {
            addBotMessage(`‚ö†Ô∏è El archivo "${file.name}" ya fue cargado.`);
            return;
          }

          mcFiles.push(file);
          saveFileToCache(file, 'mc');

          const fileDiv = document.createElement('div');
          fileDiv.id = `mc-file-${file.name}`;
          fileDiv.className = 'p-1 bg-red-50 border border-red-200 rounded text-xs flex items-center justify-between';
          fileDiv.innerHTML = `
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <i class="fas fa-file-excel text-red-600 text-xs"></i>
              <span class="font-medium text-red-900 truncate">${file.name}</span>
            </div>
            <button class="p-1 text-red-500 hover:text-red-700" onclick="removeMcFile('${file.name}')">
              <i class="fas fa-times text-xs"></i>
            </button>`;
          fileList.appendChild(fileDiv);
        });

        updateContinueButton();
      }

      function handleVisaUpload(files) {
        const fileList = document.getElementById('visa-file-list');
        
        files.forEach(file => {
          if (visaFiles.some(f => f.name === file.name)) {
            addBotMessage(`‚ö†Ô∏è El archivo "${file.name}" ya fue cargado.`);
            return;
          }

          visaFiles.push(file);
          saveFileToCache(file, 'visa');

          const fileDiv = document.createElement('div');
          fileDiv.id = `visa-file-${file.name}`;
          fileDiv.className = 'p-1 bg-purple-50 border border-purple-200 rounded text-xs flex items-center justify-between';
          fileDiv.innerHTML = `
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <i class="fas fa-file-excel text-purple-600 text-xs"></i>
              <span class="font-medium text-purple-900 truncate">${file.name}</span>
            </div>
            <button class="p-1 text-red-500 hover:text-red-700" onclick="removeVisaFile('${file.name}')">
              <i class="fas fa-times text-xs"></i>
            </button>`;
          fileList.appendChild(fileDiv);
        });

        updateContinueButton();
      }

      function updateContinueButton() {
        const reconcileBtn = document.getElementById('continue-step-3');
        const hasFiles = amexFiles.length > 0 || dinersFiles.length > 0 || mcFiles.length > 0 || visaFiles.length > 0 || payuFiles.length > 0;
        reconcileBtn.disabled = !hasFiles;
      }
      
      window.removeAmexFile = function(fileName) {
          amexFiles = amexFiles.filter(f => f.name !== fileName);
          document.getElementById(`amex-file-${fileName}`).remove();
          updateContinueButton();
      }

      window.removeDinersFile = function(fileName) {
          dinersFiles = dinersFiles.filter(f => f.name !== fileName);
          document.getElementById(`diners-file-${fileName}`).remove();
          updateContinueButton();
      }

      window.removeMcFile = function(fileName) {
          mcFiles = mcFiles.filter(f => f.name !== fileName);
          document.getElementById(`mc-file-${fileName}`).remove();
          updateContinueButton();
      }

      window.removeVisaFile = function(fileName) {
          visaFiles = visaFiles.filter(f => f.name !== fileName);
          document.getElementById(`visa-file-${fileName}`).remove();
          updateContinueButton();
      }

      function handlePayuUpload(files) {
        const fileList = document.getElementById('payu-file-list');
        
        files.forEach(file => {
          if (payuFiles.some(f => f.name === file.name)) {
            addBotMessage(`‚ö†Ô∏è El archivo "${file.name}" ya fue cargado.`);
            return;
          }

          payuFiles.push(file);
          saveFileToCache(file, 'payu');

          const fileDiv = document.createElement('div');
          fileDiv.id = `payu-file-${file.name}`;
          fileDiv.className = 'p-1 bg-yellow-50 border border-yellow-200 rounded text-xs flex items-center justify-between';
          fileDiv.innerHTML = `
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <i class="fas fa-file-excel text-yellow-600 text-xs"></i>
              <span class="font-medium text-yellow-900 truncate">${file.name}</span>
            </div>
            <button class="p-1 text-red-500 hover:text-red-700" onclick="removePayuFile('${file.name}')">
              <i class="fas fa-times text-xs"></i>
            </button>`;
          fileList.appendChild(fileDiv);
        });

        updateContinueButton();
      }

      window.removePayuFile = function(fileName) {
          payuFiles = payuFiles.filter(f => f.name !== fileName);
          document.getElementById(`payu-file-${fileName}`).remove();
          updateContinueButton();
      }
      
      // --- CORE LOGIC ---
      async function processFile() {
          const hasAnyFile = amexFiles.length > 0 || dinersFiles.length > 0 || mcFiles.length > 0 || visaFiles.length > 0 || payuFiles.length > 0;
          if (!uploadedFile || !hasAnyFile) {
              addBotMessage('‚ùå Faltan archivos para procesar. Aseg√∫rate de haber cargado el extracto y al menos un archivo de conciliaci√≥n.');
              showStep(uploadedFile ? 3 : 2);
              return;
          }

          try {
              // 1. Definir los encabezados de ENTRADA (archivos originales)
              const INPUT_EXTRACTO_HEADERS = ['FECHA', 'DESCRIPCI√ìN OPERACI√ìN', 'MONTO', 'OPERACI√ìN - N√öMERO', 'REFERENCIA2'];
              const INPUT_AMEX_HEADERS = ['CODIGO', 'NETO_TOTAL', 'FECHA_ABONO'];
              const INPUT_DINERS_HEADERS = ['C√ìDIGO DE COMERCIO', 'ORDEN DE PAGO', 'FECHA DE PAGO', 'IMPORTE NETO DE PAGO'];
              const INPUT_MC_HEADERS = ['CODCOM', 'NETO_TOTAL', 'FECHA_ABONO'];
              const INPUT_VISA_HEADERS = ['COMERCIO/CADENA', 'FECHA PROCESO', 'IMPORTE NETO'];
              const INPUT_PAYU_HEADERS = ['FECHA', 'DOCUMENTO', 'DESCRIPCION', 'CREDITOS', 'DEBITOS', 'NUEVO SALDO', 'SALDO CONGELADO ANTERIOR', 'SALDO RESERVA', 'SALDO DISPONIBLE'];

              // 2. Definir los encabezados de SALIDA (con columnas a√±adidas)
              const FINAL_EXTRACTO_HEADERS = ['FECHA', 'DESCRIPCI√ìN OPERACI√ìN', 'MONTO', 'OPERACI√ìN - N√öMERO', 'REFERENCIA2', 'ESTADO', '#REF'];
              const FINAL_AMEX_HEADERS = ['CODIGO', 'NETO_TOTAL', 'FECHA_ABONO', 'ESTADO', '#REF'];
              const FINAL_DINERS_HEADERS = ['C√ìDIGO DE COMERCIO', 'ORDEN DE PAGO', 'FECHA DE PAGO', 'IMPORTE NETO DE PAGO', 'ESTADO', '#REF'];
              const FINAL_MC_HEADERS = ['CODCOM', 'NETO_TOTAL', 'FECHA_ABONO', 'ESTADO', '#REF'];
              const FINAL_VISA_HEADERS = ['COMERCIO/CADENA', 'FECHA PROCESO', 'IMPORTE NETO', 'ESTADO', '#REF'];
              const FINAL_PAYU_HEADERS = ['FECHA', 'DOCUMENTO', 'DESCRIPCION', 'CREDITOS', 'DEBITOS', 'NUEVO SALDO', 'SALDO CONGELADO ANTERIOR', 'SALDO RESERVA', 'SALDO DISPONIBLE', 'ESTADO', '#REF'];

              // 3. Leer el archivo de extracto. Requerimos las columnas de entrada.
              const requiredExtractHeaders = [...new Set(['DESCRIPCI√ìN OPERACI√ìN', ...INPUT_EXTRACTO_HEADERS])];
              const [rawExtractHeaders, ...rawExtractData] = await readFileAndGetData(uploadedFile, {
                  headerRow: 5,
                  requiredHeaders: requiredExtractHeaders
              });
              
              // 3. Filtrar el extracto por 'Descripci√≥n operaci√≥n'
              const descColIndex = rawExtractHeaders.findIndex(h => h.toUpperCase().trim() === 'DESCRIPCI√ìN OPERACI√ìN');
              const filteredRawExtractData = rawExtractData.filter(row => {
                  const desc = row[descColIndex] ? String(row[descColIndex]).toUpperCase() : '';
                  return desc.endsWith('DINERS CLUB') || 
                         desc.endsWith('CIA DE SERV') || 
                         desc.endsWith('DE PROCESOS DE MEDIOS') ||
                         desc.endsWith('DINERS CLUB PERU S.') ||
                         desc.includes('COMPAN');
              });

              // 4. Mapear las columnas del extracto ya filtrado al formato de entrada
              const extractoHeaderMap = INPUT_EXTRACTO_HEADERS.map(h => rawExtractHeaders.findIndex(rawH => rawH.toUpperCase().trim() === h));
              const mappedExtractoData = filteredRawExtractData.map(row => extractoHeaderMap.map(index => row[index]));
              
              // 5. Agregar columnas ESTADO y #REF con valores iniciales
              const extractoDataWithEstado = mappedExtractoData.map(row => [...row, 'Pendiente', '']);
              
              // 6. Consolidar y mapear archivos AMEX
              let consolidatedAmexData = [];
              if (amexFiles.length > 0) {
                  for (const file of amexFiles) {
                      // console.log(`üìÑ Procesando archivo AMEX: ${file.name}`);
                      const [rawAmexHeaders, ...rawAmexData] = await readFileAndGetData(file, { requiredHeaders: INPUT_AMEX_HEADERS });
                      const amexHeaderMap = INPUT_AMEX_HEADERS.map(h => rawAmexHeaders.findIndex(rawH => rawH.toUpperCase().trim() === h));
                      const mappedAmex = rawAmexData.map(row => amexHeaderMap.map(index => row[index]));
                      consolidatedAmexData.push(...mappedAmex);
                  }

                  // 5.1. Filtrar AMEX por Neto_Total != 0
                  const netoTotalIndex = INPUT_AMEX_HEADERS.indexOf('NETO_TOTAL');
                  consolidatedAmexData = consolidatedAmexData.filter(row => {
                      const netoTotal = convertToNumber(row[netoTotalIndex]);
                      return !isNaN(netoTotal) && netoTotal !== 0;
                  });
                  // console.log(`üìä AMEX: ${consolidatedAmexData.length} filas v√°lidas despu√©s del filtro`);
              }

              // 6. Consolidar y mapear archivos DINERS
              let consolidatedDinersData = [];
              if (dinersFiles.length > 0) {
                  for (const file of dinersFiles) {
                      // console.log(`üìÑ Procesando archivo DINERS: ${file.name}`);
                      const [rawDinersHeaders, ...rawDinersData] = await readFileAndGetData(file, { requiredHeaders: INPUT_DINERS_HEADERS });
                      const dinersHeaderMap = INPUT_DINERS_HEADERS.map(h => rawDinersHeaders.findIndex(rawH => rawH.toUpperCase().trim() === h));
                      
                      // Filtrar filas que tienen datos en al menos una columna requerida
                      const filteredDinersData = rawDinersData.filter(row => {
                          return dinersHeaderMap.some(index => {
                              const value = row[index];
                              return value !== null && value !== undefined && String(value).trim() !== '';
                          });
                      });
                      
                      const mappedDiners = filteredDinersData.map(row => dinersHeaderMap.map(index => row[index]));
                      consolidatedDinersData.push(...mappedDiners);
                  }
                  // console.log(`üìä DINERS: ${consolidatedDinersData.length} filas v√°lidas despu√©s del filtro`);
              }

              // 7. Consolidar y mapear archivos MASTERCARD
              let consolidatedMcData = [];
              if (mcFiles.length > 0) {
                  for (const file of mcFiles) {
                      // console.log(`üìÑ Procesando archivo MC: ${file.name}`);
                      const codcom = file.name.split('-')[0];
                      const [rawMcHeaders, ...rawMcData] = await readFileAndGetData(file, { requiredHeaders: ['NETO_TOTAL', 'FECHA_ABONO'] });
                      
                      const netoTotalIndex = rawMcHeaders.findIndex(h => h.toUpperCase().trim() === 'NETO_TOTAL');
                      const fechaAbonoIndex = rawMcHeaders.findIndex(h => h.toUpperCase().trim() === 'FECHA_ABONO');

                      const mappedMc = rawMcData
                          .map(row => [codcom, row[netoTotalIndex], row[fechaAbonoIndex]])
                          .filter(row => {
                              // Filtrar filas que no tienen datos o cuyo Neto_Total es 0
                              const netoTotal = convertToNumber(row[1]);
                              return !isNaN(netoTotal) && netoTotal !== 0;
                          });

                      consolidatedMcData.push(...mappedMc);
                  }
                  // console.log(`üìä MC: ${consolidatedMcData.length} filas v√°lidas despu√©s del filtro`);
              }

              // 8. Consolidar y mapear archivos VISA
              let consolidatedVisaData = [];
              if (visaFiles.length > 0) {
                  for (const file of visaFiles) {
                      // console.log(`üìÑ Procesando archivo VISA: ${file.name}`);
                      const [rawVisaHeaders, ...rawVisaData] = await readFileAndGetData(file, { requiredHeaders: INPUT_VISA_HEADERS });
                      
                      const comercioIndex = rawVisaHeaders.findIndex(h => h.toUpperCase().trim() === 'COMERCIO/CADENA');
                      const fechaProcesoIndex = rawVisaHeaders.findIndex(h => h.toUpperCase().trim() === 'FECHA PROCESO');
                      const importeNetoIndex = rawVisaHeaders.findIndex(h => h.toUpperCase().trim() === 'IMPORTE NETO');

                      const mappedVisa = rawVisaData
                          .map(row => [row[comercioIndex], row[fechaProcesoIndex], row[importeNetoIndex]])
                          .filter(row => {
                              const importeNeto = convertToNumber(row[2]);
                              return !isNaN(importeNeto) && importeNeto !== 0;
                          });

                      consolidatedVisaData.push(...mappedVisa);
                  }
                  // console.log(`üìä VISA: ${consolidatedVisaData.length} filas v√°lidas despu√©s del filtro`);
              }

              // 8. Consolidar y mapear archivos PAYU
              let consolidatedPayuData = [];
              if (payuFiles.length > 0) {
                  for (const file of payuFiles) {
                      // console.log(`üìÑ Procesando archivo PAYU: ${file.name}`);
                      const [rawPayuHeaders, ...rawPayuData] = await readFileAndGetData(file, { 
                          headerRow: 5,
                          requiredHeaders: INPUT_PAYU_HEADERS
                      });
                      
                      const payuHeaderMap = INPUT_PAYU_HEADERS.map(h => rawPayuHeaders.findIndex(rawH => rawH.toUpperCase().trim() === h));
                      
                      // Filtrar filas que contienen "PAYMENT_ORDER [PAYMENT_ORDER]" en DESCRIPCION
                      const descripcionIndex = rawPayuHeaders.findIndex(h => h.toUpperCase().trim() === 'DESCRIPCION');
                      const debitosIndex = rawPayuHeaders.findIndex(h => h.toUpperCase().trim() === 'DEBITOS');
                      
                      const filteredPayuData = rawPayuData.filter(row => {
                          const descripcion = String(row[descripcionIndex] || '').toUpperCase();
                          const debitos = row[debitosIndex];
                          return descripcion.includes('PAYMENT_ORDER [PAYMENT_ORDER]') && 
                                 debitos !== null && debitos !== undefined && debitos !== '' &&
                                 convertToNumber(debitos) !== 0;
                      });
                      
                      const mappedPayu = filteredPayuData.map(row => payuHeaderMap.map(index => row[index]));
                      consolidatedPayuData.push(...mappedPayu);
                  }
                  // console.log(`üìä PAYU: ${consolidatedPayuData.length} filas v√°lidas despu√©s del filtro`);
              }

              // 9. Agregar columnas ESTADO y #REF a todos los datos consolidados
              const amexDataWithEstado = consolidatedAmexData.map(row => [...row, 'Pendiente', '']);
              const dinersDataWithEstado = consolidatedDinersData.map(row => [...row, 'Pendiente', '']);
              const mcDataWithEstado = consolidatedMcData.map(row => [...row, 'Pendiente', '']);
              const visaDataWithEstado = consolidatedVisaData.map(row => [...row, 'Pendiente', '']);
              const payuDataWithEstado = consolidatedPayuData.map(row => [...row, 'Pendiente', '']);

              // 10. Realizar la Conciliaci√≥n por pasos
              const { conciliadoExtracto, conciliadoAmex, conciliadoDiners, conciliadoMc, conciliadoVisa, conciliadoPayu } = performReconciliationMultiStep(
                  [FINAL_EXTRACTO_HEADERS, ...extractoDataWithEstado],
                  [FINAL_AMEX_HEADERS, ...amexDataWithEstado],
                  [FINAL_DINERS_HEADERS, ...dinersDataWithEstado],
                  [FINAL_MC_HEADERS, ...mcDataWithEstado],
                  [FINAL_VISA_HEADERS, ...visaDataWithEstado],
                  [FINAL_PAYU_HEADERS, ...payuDataWithEstado]
              );

              // 11. Formatear fechas en salidas
              // AMEX - Formatear FECHA_ABONO
              if (conciliadoAmex.length > 0) {
                  const fechaAbonoIndexAmex = conciliadoAmex[0].indexOf('FECHA_ABONO');
                  if (fechaAbonoIndexAmex !== -1) {
                      for (let i = 1; i < conciliadoAmex.length; i++) {
                          const rawValue = conciliadoAmex[i][fechaAbonoIndexAmex];
                          const strValue = String(rawValue).trim();
                          if (strValue.length === 8 && !isNaN(strValue)) {
                              const year = strValue.substring(0, 4);
                              const month = strValue.substring(4, 6);
                              const day = strValue.substring(6, 8);
                              conciliadoAmex[i][fechaAbonoIndexAmex] = `${day}/${month}/${year}`;
                          }
                      }
                  }
              }

              // DINERS - Formatear FECHA DE PAGO
              if (conciliadoDiners.length > 0) {
                  const fechaPagoIndexDiners = conciliadoDiners[0].indexOf('FECHA DE PAGO');
                  if (fechaPagoIndexDiners !== -1) {
                      for (let i = 1; i < conciliadoDiners.length; i++) {
                          const rawValue = conciliadoDiners[i][fechaPagoIndexDiners];
                          const date = parseDate(rawValue);
                          conciliadoDiners[i][fechaPagoIndexDiners] = date ? date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }) : rawValue;
                      }
                  }
              }

              // MC - Formatear FECHA_ABONO
              if (conciliadoMc.length > 0) {
                  const fechaAbonoIndexMc = conciliadoMc[0].indexOf('FECHA_ABONO');
                  if (fechaAbonoIndexMc !== -1) {
                      for (let i = 1; i < conciliadoMc.length; i++) {
                          const rawValue = conciliadoMc[i][fechaAbonoIndexMc];
                          const date = parseDate(rawValue);
                          conciliadoMc[i][fechaAbonoIndexMc] = date ? date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }) : rawValue;
                      }
                  }
              }

              // VISA - Formatear FECHA PROCESO
              if (conciliadoVisa.length > 0) {
                  const fechaProcesoIndexVisa = conciliadoVisa[0].indexOf('FECHA PROCESO');
                  if (fechaProcesoIndexVisa !== -1) {
                      for (let i = 1; i < conciliadoVisa.length; i++) {
                          const rawValue = conciliadoVisa[i][fechaProcesoIndexVisa];
                          const date = parseDate(rawValue);
                          conciliadoVisa[i][fechaProcesoIndexVisa] = date ? date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }) : `FECHA INVALIDA (${rawValue})`;
                      }
                  }
              }

              // PAYU - Formatear FECHA
              if (conciliadoPayu.length > 0) {
                  const fechaIndexPayu = conciliadoPayu[0].indexOf('FECHA');
                  if (fechaIndexPayu !== -1) {
                      for (let i = 1; i < conciliadoPayu.length; i++) {
                          const rawValue = conciliadoPayu[i][fechaIndexPayu];
                          const date = parseDate(rawValue);
                          conciliadoPayu[i][fechaIndexPayu] = date ? date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }) : rawValue;
                      }
                  }
              }

              processedData = { 
                  extracto: conciliadoExtracto, 
                  amex: conciliadoAmex.length > 0 ? conciliadoAmex : [],
                  diners: conciliadoDiners.length > 0 ? conciliadoDiners : [],
                  mc: conciliadoMc.length > 0 ? conciliadoMc : [],
                  visa: conciliadoVisa.length > 0 ? conciliadoVisa : [],
                  payu: conciliadoPayu.length > 0 ? conciliadoPayu : []
              };
              goToStep5();

          } catch (error) {
              console.error('Error en el proceso de conciliaci√≥n:', error);
              addBotMessage(`‚ùå Error en la conciliaci√≥n: ${error.message}`);
              showStep(3); // Volver al paso de carga de AMEX si algo falla
          }
      }

      function performReconciliationMultiStep(extractoConHeaders, amexConHeaders, dinersConHeaders, mcConHeaders, visaConHeaders, payuConHeaders) {
          // console.log('\nüîÑ INICIANDO CONCILIACI√ìN POR PASOS');
          
          const [extractoHeaders, ...extractoData] = extractoConHeaders;
          const [amexHeaders, ...amexData] = amexConHeaders.length > 0 ? amexConHeaders : [[], []];
          const [dinersHeaders, ...dinersData] = dinersConHeaders.length > 0 ? dinersConHeaders : [[], []];
          const [mcHeaders, ...mcData] = mcConHeaders.length > 0 ? mcConHeaders : [[], []];
          const [visaHeaders, ...visaData] = visaConHeaders.length > 0 ? visaConHeaders : [[], []];
          const [payuHeaders, ...payuData] = payuConHeaders.length > 0 ? payuConHeaders : [[], []];

          // √çndices de columnas clave
          const fechaExtractoIndex = extractoHeaders.indexOf('FECHA');
          const montoExtractoIndex = extractoHeaders.indexOf('MONTO');
          const opNumExtractoIndex = extractoHeaders.indexOf('OPERACI√ìN - N√öMERO');
          const descExtractoIndex = extractoHeaders.indexOf('DESCRIPCI√ìN OPERACI√ìN');
          const ref2ExtractoIndex = extractoHeaders.indexOf('REFERENCIA2');
          
          // Usar headers y datos ya incluidos con ESTADO y #REF
          const finalExtractoHeaders = extractoHeaders;
          let dataExtractoConEstado = extractoData; // Ya incluye ESTADO y #REF

          // Preparar AMEX si hay datos
          let finalAmexHeaders = [];
          let dataAmexConEstado = [];
          let amexMap = new Map();
          
          if (amexData.length > 0) {
              const codAmexIndex = amexHeaders.indexOf('CODIGO');
              const netoAmexIndex = amexHeaders.indexOf('NETO_TOTAL');
              const fechaAbonoAmexIndex = amexHeaders.indexOf('FECHA_ABONO');
              
              finalAmexHeaders = amexHeaders;
              dataAmexConEstado = amexData; // Ya incluye ESTADO y #REF

              // console.log('\nüìä PASO 2: Procesando AMEX para conciliaci√≥n');
              dataAmexConEstado.forEach((row, index) => {
                  const fechaRaw = row[fechaAbonoAmexIndex];
                  const montoRaw = row[netoAmexIndex];
                  
                  let fechaKey = null;
                  if (fechaRaw && String(fechaRaw).length === 8) {
                      const str = String(fechaRaw);
                      const year = str.substring(0, 4);
                      const month = str.substring(4, 6);
                      const day = str.substring(6, 8);
                      fechaKey = `${year}-${month}-${day}`;
                  }
                  
                  const monto = convertToNumber(montoRaw);
                  
                  if (fechaKey && !isNaN(monto)) {
                      const key = `${fechaKey}_${monto.toFixed(2)}`;
                      // console.log(`[AMEX ${index}] Key: "${key}" | C√≥digo: ${row[codAmexIndex]}`);
                      
                      if (!amexMap.has(key)) amexMap.set(key, []);
                      amexMap.get(key).push({ row, index });
                  }
              });
          }

          // Preparar DINERS si hay datos
          let finalDinersHeaders = [];
          let datadinersConEstado = [];
          let dinersMap = new Map();
          
          if (dinersData.length > 0) {
              const codComDinersIndex = dinersHeaders.indexOf('C√ìDIGO DE COMERCIO');
              const ordenPagoDinersIndex = dinersHeaders.indexOf('ORDEN DE PAGO');
              const fechaPagoDinersIndex = dinersHeaders.indexOf('FECHA DE PAGO');
              const importeNetoDinersIndex = dinersHeaders.indexOf('IMPORTE NETO DE PAGO');
              
              finalDinersHeaders = dinersHeaders;
              datadinersConEstado = dinersData; // Ya incluye ESTADO y #REF

              // console.log('\nüéØ PASO 3: Procesando DINERS para conciliaci√≥n');
              
              // NUEVO PROCESAMIENTO DINERS: Agrupar por orden de pago, luego por fecha de pago
              const dinersGroupsByOrder = new Map(); // Primer nivel: agrupar por orden de pago
              
              datadinersConEstado.forEach((row, index) => {
                  const ordenPago = String(row[ordenPagoDinersIndex] || '').trim();
                  const fechaPago = row[fechaPagoDinersIndex];
                  const importeNeto = row[importeNetoDinersIndex];
                  
                  // Solo procesar si tiene orden de pago v√°lida, fecha y importe
                  if (ordenPago && fechaPago && importeNeto !== null && importeNeto !== undefined) {
                      const last10 = ordenPago.slice(-10);
                      
                      if (last10.length === 10) {
                          if (!dinersGroupsByOrder.has(last10)) {
                              dinersGroupsByOrder.set(last10, new Map()); // Segundo nivel: Map por fecha
                          }
                          
                          // Convertir fecha a formato comparable
                          let fechaKey = null;
                          if (fechaPago) {
                              if (typeof fechaPago === 'number' && fechaPago > 40000) {
                                  // Fecha de Excel (n√∫mero de d√≠as desde 1900)
                                  const excelDate = new Date((fechaPago - 25569) * 86400 * 1000);
                                  fechaKey = excelDate.toISOString().split('T')[0]; // YYYY-MM-DD
                              } else if (typeof fechaPago === 'string') {
                                  // Manejar formato DD-MM-YYYY o DD/MM/YYYY de DINERS
                                  const fechaStr = fechaPago.trim();
                                  let parsedDate = null;
                                  
                                  // Intentar formato DD-MM-YYYY o DD/MM/YYYY
                                  if (fechaStr.match(/^\d{1,2}[-\/]\d{1,2}[-\/]\d{4}$/)) {
                                      const parts = fechaStr.split(/[-\/]/);
                                      if (parts.length === 3) {
                                          const day = parseInt(parts[0], 10);
                                          const month = parseInt(parts[1], 10) - 1; // Mes base 0
                                          const year = parseInt(parts[2], 10);
                                          parsedDate = new Date(year, month, day);
                                      }
                                  } else {
                                      // Intentar parseo est√°ndar
                                      parsedDate = new Date(fechaPago);
                                  }
                                  
                                  if (parsedDate && !isNaN(parsedDate.getTime())) {
                                      fechaKey = parsedDate.toISOString().split('T')[0];
                                  }
                              }
                          }
                          
                          if (fechaKey) {
                              const orderGroup = dinersGroupsByOrder.get(last10);
                              if (!orderGroup.has(fechaKey)) {
                                  orderGroup.set(fechaKey, []);
                              }
                              orderGroup.get(fechaKey).push({ row, index, fechaKey });
                              // console.log(`[DINERS ${index}] Orden: ${last10} | Fecha Original: ${fechaPago} | Fecha Parseada: ${fechaKey} | Importe: ${importeNeto}`);
                          }
                      }
                  }
              });

              // Crear mapa final: combinar orden + fecha como clave, con total del grupo
              dinersGroupsByOrder.forEach((fechaGroups, ordenPago) => {
                  fechaGroups.forEach((items, fechaPago) => {
                      const total = items.reduce((sum, item) => {
                          const importe = convertToNumber(item.row[importeNetoDinersIndex]);
                          return sum + (isNaN(importe) ? 0 : importe);
                      }, 0);
                      
                      // Clave compuesta: orden_fecha para identificaci√≥n √∫nica
                      const compositeKey = `${ordenPago}_${fechaPago}`;
                      dinersMap.set(compositeKey, { 
                          total: total.toFixed(2), 
                          items: items,
                          ordenPago: ordenPago,
                          fechaPago: fechaPago
                      });
                      // console.log(`[DINERS GRUPO] ${compositeKey} -> Total: ${total.toFixed(2)} (${items.length} items)`);
                  });
              });
          }

          // Preparar MC si hay datos - L√çNEA POR L√çNEA (sin agrupar por fecha)
          let finalMcHeaders = [];
          let datamcConEstado = [];
          let mcCommerceMap = new Map(); // Mapa simple por comercio: CODCOM -> [registros individuales]
          
          if (mcData.length > 0) {
              finalMcHeaders = mcHeaders;
              datamcConEstado = mcData; // Ya incluye ESTADO y #REF
              const codComMcIndex = mcHeaders.indexOf('CODCOM');
              const netoMcIndex = mcHeaders.indexOf('NETO_TOTAL');

              // Crear mapa simple l√≠nea por l√≠nea: CODCOM -> registros individuales
              datamcConEstado.forEach((row, index) => {
                  const codcom = String(row[codComMcIndex] || '').trim();
                  const monto = convertToNumber(row[netoMcIndex]);

                  if (codcom && !isNaN(monto) && monto !== 0) {
                      if (!mcCommerceMap.has(codcom)) {
                          mcCommerceMap.set(codcom, []);
                      }
                      mcCommerceMap.get(codcom).push({
                          row,
                          index,
                          monto: parseFloat(monto.toFixed(2))
                      });
                  }
              });
              // console.log(`[MC] Mapa de comercios creado con ${mcCommerceMap.size} comercios (l√≠nea por l√≠nea).`);
          }

          // Preparar VISA si hay datos - AGRUPAR POR FECHA PROCESO Y TOTALIZAR POR COMERCIO
          let finalVisaHeaders = [];
          let datavisaConEstado = [];
          let visaCommerceMap = new Map(); // Mapa: COMERCIO/CADENA -> { total, fechaProceso, items }
          
          if (visaData.length > 0) {
              finalVisaHeaders = visaHeaders;
              datavisaConEstado = visaData; // Ya incluye ESTADO y #REF
              const comercioVisaIndex = visaHeaders.indexOf('COMERCIO/CADENA');
              const fechaProcesoVisaIndex = visaHeaders.indexOf('FECHA PROCESO');
              const importeNetoVisaIndex = visaHeaders.indexOf('IMPORTE NETO');

              // 1. Agrupar por FECHA PROCESO
              let visaFechaGroups = new Map();
              datavisaConEstado.forEach((row, index) => {
                  const comercio = String(row[comercioVisaIndex] || '').trim();
                  const fecha = parseDate(row[fechaProcesoVisaIndex]);
                  const monto = convertToNumber(row[importeNetoVisaIndex]);

                  if (comercio && fecha && !isNaN(monto)) {
                      const fechaKey = createDateKey(row[fechaProcesoVisaIndex]);
                      
                      if (!visaFechaGroups.has(fechaKey)) visaFechaGroups.set(fechaKey, new Map());
                      const fechaGroup = visaFechaGroups.get(fechaKey);
                      
                      if (!fechaGroup.has(comercio)) fechaGroup.set(comercio, { total: 0, items: [] });
                      const comercioGroup = fechaGroup.get(comercio);
                      comercioGroup.total += monto;
                      comercioGroup.items.push({ row, index });
                  }
              });

              // 2. Crear mapa final: COMERCIO -> { total, fechaProceso, items }
              visaFechaGroups.forEach((fechaGroup, fechaKey) => {
                  fechaGroup.forEach((comercioGroup, comercio) => {
                      if (!visaCommerceMap.has(comercio)) {
                          visaCommerceMap.set(comercio, []);
                      }
                      visaCommerceMap.get(comercio).push({
                          fechaProceso: fechaKey,
                          total: parseFloat(comercioGroup.total.toFixed(2)),
                          items: comercioGroup.items
                  });
              });
              });
              
              // console.log(`[VISA] Mapa de comercios creado con ${visaCommerceMap.size} comercios (agrupado por fecha y totalizado).`);
          }

          // Preparar PAYU si hay datos
          let finalPayuHeaders = [];
          let datapayuConEstado = [];
          let payuMap = new Map();
          
          if (payuData.length > 0) {
              const fechaPayuIndex = payuHeaders.indexOf('FECHA');
              const debitosPayuIndex = payuHeaders.indexOf('DEBITOS');
              
              finalPayuHeaders = payuHeaders;
              datapayuConEstado = payuData; // Ya incluye ESTADO y #REF

              // console.log('\nüí∞ PASO 6: Procesando PAYU para conciliaci√≥n');
              datapayuConEstado.forEach((row, index) => {
                  const fechaRaw = row[fechaPayuIndex];
                  const debitosRaw = row[debitosPayuIndex];
                  
                  const fecha = parseDate(fechaRaw);
                  let fechaKey = null;
                  if (fecha) {
                      const year = fecha.getUTCFullYear();
                      const month = String(fecha.getUTCMonth() + 1).padStart(2, '0');
                      const day = String(fecha.getUTCDate()).padStart(2, '0');
                      fechaKey = `${year}-${month}-${day}`;
                  }
                  
                  const debitos = Math.abs(convertToNumber(debitosRaw)); // Valor absoluto de d√©bitos
                  
                  if (fechaKey && !isNaN(debitos)) {
                      const key = `${fechaKey}_${debitos.toFixed(2)}`;
                      // console.log(`[PAYU ${index}] Key: "${key}" | D√©bitos: ${debitos}`);
                      
                      if (!payuMap.has(key)) payuMap.set(key, []);
                      payuMap.get(key).push({ row, index });
                  }
              });
          }

          // PASO 2: Conciliaci√≥n AMEX
          let conciliadosAmexF2 = 0; // Fase 2: fecha + monto
          let conciliadosAmexF3 = 0; // Fase 3: solo monto
          let conciliadosAmex = 0;   // Total AMEX
          if (amexMap.size > 0) {
              // console.log('\nüîÑ PASO 2: Conciliando con AMEX');
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return; // Ya conciliado

                  const fechaRaw = row[fechaExtractoIndex];
                  const montoRaw = row[montoExtractoIndex];
                  
                  const fecha = parseDate(fechaRaw);
                  let fechaKey = null;
                  if (fecha) {
                      const year = fecha.getUTCFullYear();
                      const month = String(fecha.getUTCMonth() + 1).padStart(2, '0');
                      const day = String(fecha.getUTCDate()).padStart(2, '0');
                      fechaKey = `${year}-${month}-${day}`;
                  }
                  
                  const monto = convertToNumber(montoRaw);
                  
                  if (fechaKey && !isNaN(monto)) {
                      const key = `${fechaKey}_${monto.toFixed(2)}`;
                      
                      if (amexMap.has(key)) {
                          const matches = amexMap.get(key);
                          if (matches.length > 0) {
                              const matchData = matches.shift();
                              const matchRow = matchData.row;
                              
                              const codCom = matchRow[amexHeaders.indexOf('CODIGO')];
                              const opNum = row[opNumExtractoIndex];
                              const fechaStr = fecha.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
                              
                              // Marcar como conciliado con prefijo P2-F2
                              row[row.length - 2] = 'P2-F2-Conciliado';
                              row[row.length - 1] = `${codCom} - ${fechaStr}`;
                              matchRow[matchRow.length - 2] = 'P2-F2-Conciliado';
                              matchRow[matchRow.length - 1] = `${opNum} - ${fechaStr}`;
                              
                              conciliadosAmexF2++;
                              conciliadosAmex++;
                              // console.log(`[EXTRACTO ${index}] ‚úÖ P2-F2-Conciliado con AMEX c√≥digo ${codCom}`);
                              
                              if (matches.length === 0) amexMap.delete(key);
                          }
                      }
                  }
              });

              // PASO 2 - FASE 3: Conciliaci√≥n AMEX solo por monto (fechas diferentes)
              // console.log('\nüîÑ PASO 2 - FASE 3: Conciliando AMEX (solo monto, fechas diferentes)');

              // Crear mapa solo por monto para registros no conciliados en FASE 2
              const amexMontoMap = new Map();

              // Obtener √≠ndices de columnas para FASE 3
              const netoAmexIndexF3 = amexHeaders.indexOf('NETO_TOTAL');
              const codAmexIndexF3 = amexHeaders.indexOf('CODIGO');

              // Procesar solo registros AMEX no conciliados en FASE 2
              dataAmexConEstado.forEach((row, index) => {
                  if (row[row.length - 2] === 'Pendiente') { // Solo procesar pendientes de FASE 2
                      const montoRaw = row[netoAmexIndexF3];
                      const monto = convertToNumber(montoRaw);

                      if (!isNaN(monto)) {
                          const montoKey = monto.toFixed(2);
                          // console.log(`[AMEX F3 ${index}] Monto: "${montoKey}" | C√≥digo: ${row[codAmexIndexF3]}`);

                          if (!amexMontoMap.has(montoKey)) amexMontoMap.set(montoKey, []);
                          amexMontoMap.get(montoKey).push({ row, index });
                      }
                  }
              });

              // Conciliar por monto con registros pendientes del extracto
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return; // Solo procesar pendientes de FASE 2

                  const montoRaw = row[montoExtractoIndex];
                  const monto = convertToNumber(montoRaw);

                  if (!isNaN(monto)) {
                      const montoKey = monto.toFixed(2);

                      if (amexMontoMap.has(montoKey)) {
                          const matches = amexMontoMap.get(montoKey);
                          if (matches.length > 0) {
                              const matchData = matches.shift();
                              const matchRow = matchData.row;

                              const codCom = matchRow[amexHeaders.indexOf('CODIGO')];
                              const opNum = row[opNumExtractoIndex];
                              const fechaExtractoStr = parseDate(row[fechaExtractoIndex]);
                              const fechaExtractoFormatted = fechaExtractoStr ?
                                  fechaExtractoStr.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' }) :
                                  'Fecha inv√°lida';

                              // Marcar como conciliado con prefijo P2-F3
                              row[row.length - 2] = 'P2-F3-Conciliado';
                              row[row.length - 1] = `${codCom} - Monto: ${montoKey} (fechas diferentes)`;
                              matchRow[matchRow.length - 2] = 'P2-F3-Conciliado';
                              matchRow[matchRow.length - 1] = `${opNum} - Monto: ${montoKey} (fechas diferentes)`;

                              conciliadosAmexF3++;
                              conciliadosAmex++;
                              // console.log(`[EXTRACTO ${index}] ‚úÖ P2-F3-Conciliado con AMEX c√≥digo ${codCom} (fechas diferentes)`);

                              // Eliminar el monto del mapa cuando ya no quedan matches disponibles
                              // Esto previene que el mismo registro AMEX se use m√∫ltiples veces
                              if (matches.length === 0) {
                                  // console.log(`[AMEX F3] Eliminando monto "${montoKey}" del mapa (sin matches restantes)`);
                                  amexMontoMap.delete(montoKey);
                              }
                          }
                      }
                  }
              });

              // Log resumen de la fase 3
              // console.log(`[F3 RESUMEN] ${conciliadosAmexF3} conciliaciones realizadas en fase 3`);
          }

          // PASO 3: Conciliaci√≥n DINERS (NUEVA L√ìGICA: por fecha y monto)
          let conciliadosDiners = 0;
          if (dinersMap.size > 0) {
              // console.log('\nüéØ PASO 3: Conciliando con DINERS por fecha y monto');
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return; // Ya conciliado

                  const fechaExtracto = row[fechaExtractoIndex];
                  const montoRaw = row[montoExtractoIndex];
                  const monto = convertToNumber(montoRaw);
                  
                  if (fechaExtracto && !isNaN(monto)) {
                      // Convertir fecha del extracto a formato comparable
                      let fechaExtractoKey = null;
                      if (typeof fechaExtracto === 'number' && fechaExtracto > 40000) {
                          // Fecha de Excel
                          const excelDate = new Date((fechaExtracto - 25569) * 86400 * 1000);
                          fechaExtractoKey = excelDate.toISOString().split('T')[0];
                      } else if (typeof fechaExtracto === 'string') {
                          // Manejar formato DD/MM/YYYY del extracto
                          const fechaStr = fechaExtracto.trim();
                          let parsedDate = null;
                          
                          // Intentar formato DD/MM/YYYY o DD-MM-YYYY
                          if (fechaStr.match(/^\d{1,2}[-\/]\d{1,2}[-\/]\d{4}$/)) {
                              const parts = fechaStr.split(/[-\/]/);
                              if (parts.length === 3) {
                                  const day = parseInt(parts[0], 10);
                                  const month = parseInt(parts[1], 10) - 1; // Mes base 0
                                  const year = parseInt(parts[2], 10);
                                  parsedDate = new Date(year, month, day);
                              }
                          } else {
                              // Intentar parseo est√°ndar
                              parsedDate = new Date(fechaExtracto);
                          }
                          
                          if (parsedDate && !isNaN(parsedDate.getTime())) {
                              fechaExtractoKey = parsedDate.toISOString().split('T')[0];
                          }
                      }
                      
                      if (fechaExtractoKey) {
                          // Buscar coincidencia por fecha y monto en los grupos DINERS
                          console.log(`[EXTRACTO ${index}] Fecha Original: ${fechaExtracto} | Fecha Parseada: ${fechaExtractoKey} | Monto: ${monto}`);
                          for (const [compositeKey, dinersGroup] of dinersMap.entries()) {
                              const dinersTotal = parseFloat(dinersGroup.total);
                              const dinersFecha = dinersGroup.fechaPago;
                              
                              console.log(`[COMPARANDO] Extracto: ${fechaExtractoKey} vs DINERS: ${dinersFecha} | Monto Extracto: ${monto} vs DINERS: ${dinersTotal}`);
                              
                              // Comparar fecha y monto
                              if (dinersFecha === fechaExtractoKey && Math.abs(monto - dinersTotal) < 0.01) {
                                  const opNum = row[opNumExtractoIndex];
                                  const ordenPago = dinersGroup.ordenPago;
                                  
                                  // Marcar extracto como conciliado
                                  row[row.length - 2] = 'P3 - CONCILIADO';
                                  row[row.length - 1] = `${ordenPago} - ${dinersFecha}`;
                                  
                                  // Marcar todos los items DINERS del grupo como conciliados
                                  dinersGroup.items.forEach(item => {
                                      item.row[item.row.length - 2] = 'P3 - CONCILIADO';
                                      item.row[item.row.length - 1] = `${opNum} - ${ordenPago} - ${dinersFecha}`;
                                  });
                                  
                                  conciliadosDiners++;
                                  // console.log(`[EXTRACTO ${index}] ‚úÖ P3 - CONCILIADO con DINERS | Fecha: ${dinersFecha} | Monto: ${dinersTotal} | Orden: ${ordenPago}`);
                                  
                                  // Remover del mapa para evitar re-matches
                                  dinersMap.delete(compositeKey);
                                  break; // Salir del loop una vez encontrada la coincidencia
                              }
                          }
                      }
                  }
              });
          }

          // PASO 4: Conciliaci√≥n MC (3 FASES)
          let conciliadosMc = 0;
          let conciliadosMcF1 = 0;
          let conciliadosMcF2 = 0;
          let conciliadosMcF3 = 0;
          if (mcCommerceMap.size > 0) {
              // console.log('\nüí≥ PASO 4: Conciliando con MC (3 Fases)');
              // console.log(`[PASO 4] Comercios MC disponibles:`, Array.from(mcCommerceMap.keys()));
              
              // mcCommerceMap.forEach((registros, comercio) => {
              //     console.log(`[PASO 4] Comercio ${comercio}: ${registros.length} registros individuales`);
              //     registros.forEach((registro, idx) => {
              //         console.log(`  Registro ${idx}: Monto: ${registro.monto}`);
              //     });
              // });

              // FASE 1: Conciliaci√≥n por CODCOM + MONTO (l√≠nea por l√≠nea)
              // console.log('\nüîÑ PASO 4 - FASE 1: Conciliando MC (CODCOM + MONTO)');
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return;

                  const referencia2 = String(row[ref2ExtractoIndex] || '').trim();
                  const monto = convertToNumber(row[montoExtractoIndex]);
                  
                  if (referencia2 && !isNaN(monto)) {
                      // Extraer los 9 d√≠gitos y tomar los √∫ltimos 7
                      const match = referencia2.match(/(\d{9})/);
                      const fullCode = match ? match[1] : "";
                      const codcomKey = fullCode.slice(-7);
                      
                      // console.log(`[PASO 4-F1] Extracto ${index}: REFERENCIA2="${referencia2}" ‚Üí codcomKey="${codcomKey}" | Monto: ${monto}`);
                      
                      if (mcCommerceMap.has(codcomKey)) {
                          const potentialMatches = mcCommerceMap.get(codcomKey);
                          // console.log(`[PASO 4-F1] Encontrado comercio ${codcomKey} con ${potentialMatches.length} registros`);
                          // console.log(`[PASO 4-F1] Montos disponibles para ${codcomKey}:`, potentialMatches.map(m => m.monto));
                          const matchIndex = potentialMatches.findIndex(match => Math.abs(monto - match.monto) < 0.01);

                          if (matchIndex !== -1) {
                              const mcRecord = potentialMatches[matchIndex];
                              const opNum = row[opNumExtractoIndex];
                              const fechaProceso = parseDate(row[fechaExtractoIndex]);
                              const fechaProcesoStr = fechaProceso ? fechaProceso.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'}) : 'N/A';
                              
                              // Marcar extracto como conciliado
                              row[row.length - 2] = 'P4-F1-Conciliado';
                              row[row.length - 1] = `MC-${codcomKey} - ${fechaProcesoStr}`;
                              
                              // Marcar registro MC como conciliado
                              mcRecord.row[mcRecord.row.length - 2] = 'P4-F1-Conciliado';
                              mcRecord.row[mcRecord.row.length - 1] = `${opNum} - ${fechaProcesoStr}`;
                              
                              conciliadosMcF1++;
                              conciliadosMc++;
                              // console.log(`[PASO 4-F1] ‚úÖ CONCILIADO: Extracto ${index} con MC registro | Monto: ${monto}`);
                              potentialMatches.splice(matchIndex, 1); // Eliminar el registro para no reutilizarlo
                          } else {
                              // console.log(`[PASO 4-F1] ‚ùå NO MATCH: Comercio ${codcomKey} encontrado pero sin coincidencia de monto ${monto}`);
                          }
                      } else {
                          // console.log(`[PASO 4-F1] ‚ùå NO FOUND: Comercio ${codcomKey} no existe en mcCommerceMap`);
                      }
                  }
              });

              // FASE 2: Conciliaci√≥n solo por MONTO (como AMEX Fase 3)
              // console.log('\nüîÑ PASO 4 - FASE 2: Conciliando MC (solo MONTO)');
              const mcMontoMap = new Map();
              
              // Crear mapa de montos MC pendientes
              mcCommerceMap.forEach((registros, comercio) => {
                  registros.forEach(registro => {
                      if (registro.row[registro.row.length - 2] === 'Pendiente') {
                          const montoKey = registro.monto.toFixed(2);
                          if (!mcMontoMap.has(montoKey)) mcMontoMap.set(montoKey, []);
                          mcMontoMap.get(montoKey).push(registro);
                      }
                  });
              });

              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return;

                  const monto = convertToNumber(row[montoExtractoIndex]);
                  if (!isNaN(monto)) {
                      const montoKey = monto.toFixed(2);
                      
                      if (mcMontoMap.has(montoKey)) {
                          const matches = mcMontoMap.get(montoKey);
                          if (matches.length > 0) {
                              const mcRecord = matches.shift();
                              const opNum = row[opNumExtractoIndex];
                              const fechaProceso = parseDate(row[fechaExtractoIndex]);
                              const fechaProcesoStr = fechaProceso ? fechaProceso.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'}) : 'N/A';
                              
                              // Marcar extracto como conciliado
                              row[row.length - 2] = 'P4-F2-Conciliado';
                              row[row.length - 1] = `MC-Monto: ${montoKey} - ${fechaProcesoStr}`;
                              
                              // Marcar registro MC como conciliado
                              mcRecord.row[mcRecord.row.length - 2] = 'P4-F2-Conciliado';
                              mcRecord.row[mcRecord.row.length - 1] = `${opNum} - Monto: ${montoKey}`;
                              
                              conciliadosMcF2++;
                              conciliadosMc++;
                              // console.log(`[PASO 4-F2] ‚úÖ CONCILIADO: Extracto ${index} con MC por monto | Monto: ${monto}`);
                              
                              if (matches.length === 0) mcMontoMap.delete(montoKey);
                          }
                      }
                  }
              });

              // FASE 3: Agrupaci√≥n por fecha del extracto vs pendientes MC
              // console.log('\nüîÑ PASO 4 - FASE 3: Conciliando MC (Agrupaci√≥n por fecha extracto)');
              const extractoFechaGroups = new Map();
              
              // Agrupar extracto pendiente por fecha
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return;
                  
                  const fechaRaw = row[fechaExtractoIndex];
                  const monto = convertToNumber(row[montoExtractoIndex]);
                  
                  if (fechaRaw && !isNaN(monto)) {
                      const fechaKey = createDateKey(fechaRaw);
                      if (fechaKey) {
                          
                          if (!extractoFechaGroups.has(fechaKey)) extractoFechaGroups.set(fechaKey, { total: 0, items: [] });
                          const group = extractoFechaGroups.get(fechaKey);
                          group.total += monto;
                          group.items.push({ row, index });
                      }
                  }
              });

              // Crear lista de MC pendientes con sus totales
              const mcPendientes = [];
              mcCommerceMap.forEach((registros, comercio) => {
                  registros.forEach(registro => {
                      if (registro.row[registro.row.length - 2] === 'Pendiente') {
                          mcPendientes.push(registro);
                      }
                  });
              });

              // Conciliar totales de fecha extracto vs MC pendientes
              // console.log(`[PASO 4-F3] Procesando ${extractoFechaGroups.size} fechas de extracto vs ${mcPendientes.length} registros MC pendientes`);
              let procesedDatesMC = 0;
              extractoFechaGroups.forEach((extractoGroup, fechaKey) => {
                  procesedDatesMC++;
                  const totalExtracto = parseFloat(extractoGroup.total.toFixed(2));
                  // console.log(`[PASO 4-F3] Procesando fecha ${procesedDatesMC}/${extractoFechaGroups.size}: ${fechaKey} con total ${totalExtracto}`);
                  
                  // Buscar combinaciones de MC que sumen este total
                  const mcCombination = findCombinationBySum(mcPendientes, totalExtracto);
                  
                  if (mcCombination.length > 0) {
                      // console.log(`[PASO 4-F3] ‚úÖ CONCILIADO: Fecha ${fechaKey} total ${totalExtracto} con ${mcCombination.length} registros MC`);
                      
                      // Marcar extracto como conciliado
                      extractoGroup.items.forEach(item => {
                          item.row[item.row.length - 2] = 'P4-F3-Conciliado';
                          item.row[item.row.length - 1] = `MC-Fecha: ${fechaKey} - Total: ${totalExtracto}`;
                      });
                      
                      // Marcar MC como conciliado
                      mcCombination.forEach(mcRecord => {
                          mcRecord.row[mcRecord.row.length - 2] = 'P4-F3-Conciliado';
                          mcRecord.row[mcRecord.row.length - 1] = `Extracto-Fecha: ${fechaKey} - Total: ${totalExtracto}`;
                      });
                      
                      conciliadosMcF3 += extractoGroup.items.length;
                      conciliadosMc += extractoGroup.items.length;
                  }
              });

              // console.log(`[PASO 4] RESUMEN: F1=${conciliadosMcF1}, F2=${conciliadosMcF2}, F3=${conciliadosMcF3}, Total=${conciliadosMc} conciliaciones MC`);
          }

          // Funci√≥n auxiliar para crear fechas sin problemas de zona horaria
          function createDateKey(dateValue) {
              if (!dateValue) return null;
              
              const parsed = parseDate(dateValue);
              if (!parsed) return null;
              
              // Usar getFullYear, getMonth, getDate para fecha local sin UTC
              const year = parsed.getFullYear();
              const month = String(parsed.getMonth() + 1).padStart(2, '0');
              const day = String(parsed.getDate()).padStart(2, '0');
              
              const dateKey = `${year}-${month}-${day}`;
              // console.log(`[FECHA DEBUG] Input: ${dateValue} ‚Üí Parsed: ${parsed.toString()} ‚Üí Key: ${dateKey}`);
              return dateKey;
          }

          // Funci√≥n auxiliar para encontrar combinaciones que sumen un total espec√≠fico
          function findCombinationBySum(records, targetSum) {
              // Limitar el n√∫mero de registros para evitar colgarse
              const maxRecords = Math.min(records.length, 50); // M√°ximo 50 registros para evitar complejidad
              const limitedRecords = records.slice(0, maxRecords);
              
              // 1. Match exacto
              for (let i = 0; i < limitedRecords.length; i++) {
                  if (Math.abs(limitedRecords[i].monto - targetSum) < 0.01) {
                      return [limitedRecords[i]];
                  }
              }
              
              // 2. Combinaciones de 2 (limitado a primeros 20 para evitar n¬≤)
              const maxPairs = Math.min(limitedRecords.length, 20);
              for (let i = 0; i < maxPairs; i++) {
                  for (let j = i + 1; j < maxPairs; j++) {
                      const sum = limitedRecords[i].monto + limitedRecords[j].monto;
                      if (Math.abs(sum - targetSum) < 0.01) {
                          return [limitedRecords[i], limitedRecords[j]];
                      }
                  }
              }
              
              // 3. Combinaciones de 3 (limitado a primeros 10 para evitar n¬≥)
              const maxTriples = Math.min(limitedRecords.length, 10);
              for (let i = 0; i < maxTriples; i++) {
                  for (let j = i + 1; j < maxTriples; j++) {
                      for (let k = j + 1; k < maxTriples; k++) {
                          const sum = limitedRecords[i].monto + limitedRecords[j].monto + limitedRecords[k].monto;
                          if (Math.abs(sum - targetSum) < 0.01) {
                              return [limitedRecords[i], limitedRecords[j], limitedRecords[k]];
                          }
                      }
                  }
              }
              
              return []; // No encontr√≥ combinaci√≥n
          }

          // PASO 5: Conciliaci√≥n VISA (2 FASES)
          let conciliadosVisaF1 = 0;
          let conciliadosVisaF2 = 0;
          let conciliadosVisa = 0;
          
          if (visaCommerceMap.size > 0) {
              // console.log('\nüèõÔ∏è PASO 5: Conciliando con VISA (2 FASES)');
              // console.log(`[PASO 5] Comercios VISA disponibles:`, Array.from(visaCommerceMap.keys()));
              
              // FASE 1: L√≠nea de extracto vs Grupos totalizados de VISA
              // console.log('\n--- FASE 1: Extracto l√≠nea vs VISA grupos ---');
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return;

                  const referencia2 = String(row[ref2ExtractoIndex] || '').trim();
                  const monto = convertToNumber(row[montoExtractoIndex]);
                  
                  if (referencia2 && !isNaN(monto)) {
                      // Extraer los 9 d√≠gitos y tomar los √∫ltimos 7
                      const match = referencia2.match(/(\d{9})/);
                      const fullCode = match ? match[1] : "";
                      const codcomKey = fullCode.slice(-7);
                      
                      // console.log(`[PASO 5 F1] Extracto ${index}: REFERENCIA2="${referencia2}" ‚Üí codcomKey="${codcomKey}" | Monto: ${monto}`);
                      
                      if (visaCommerceMap.has(codcomKey)) {
                          const gruposVisa = visaCommerceMap.get(codcomKey);
                          
                          // Buscar grupo VISA que coincida con el monto del extracto
                          const matchIndex = gruposVisa.findIndex(grupo => Math.abs(monto - grupo.total) < 0.01);
                          
                          if (matchIndex !== -1) {
                              const grupoVisa = gruposVisa[matchIndex];
                              const opNum = row[opNumExtractoIndex];
                              const fechaProceso = parseDate(row[fechaExtractoIndex]);
                              const fechaProcesoStr = fechaProceso ? fechaProceso.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'}) : 'N/A';
                              
                              // Marcar extracto como conciliado F1
                              row[row.length - 2] = 'P5-F1-Conciliado';
                              row[row.length - 1] = `VISA-${codcomKey} - ${fechaProcesoStr}`;
                              
                              // Marcar todos los registros VISA del grupo como conciliados F1
                              grupoVisa.items.forEach(item => {
                                  item.row[item.row.length - 2] = 'P5-F1-Conciliado';
                                  item.row[item.row.length - 1] = `${opNum} - ${fechaProcesoStr}`;
                              });
                              
                              conciliadosVisaF1++;
                              // console.log(`[PASO 5 F1] ‚úÖ CONCILIADO: Extracto ${index} con VISA grupo | Monto: ${monto}`);
                              gruposVisa.splice(matchIndex, 1); // Eliminar el grupo para no reutilizarlo
                              
                              if (gruposVisa.length === 0) {
                                  visaCommerceMap.delete(codcomKey);
                              }
                          }
                      }
                  }
              });
              
              // FASE 2: Agrupar extracto por fecha y comercio, comparar con grupos VISA
              // console.log('\n--- FASE 2: Extracto agrupado por fecha vs VISA grupos por fecha ---');
              
              // Agrupar extracto pendiente por fecha y comercio
              let extractoFechaGroups = new Map();
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return;
                  
                  const fechaRaw = row[fechaExtractoIndex];
                  const monto = convertToNumber(row[montoExtractoIndex]);
                  const referencia2 = String(row[ref2ExtractoIndex] || '').trim();
                  
                  if (fechaRaw && !isNaN(monto) && referencia2) {
                      const fechaKey = createDateKey(fechaRaw);
                      if (fechaKey) {
                          // Extraer c√≥digo de comercio
                          const match = referencia2.match(/(\d{9})/);
                          const fullCode = match ? match[1] : "";
                          const codcomKey = fullCode.slice(-7);
                          
                          if (codcomKey) {
                              const groupKey = `${fechaKey}-${codcomKey}`;
                              if (!extractoFechaGroups.has(groupKey)) {
                                  extractoFechaGroups.set(groupKey, { 
                                      fechaKey, 
                                      codcomKey, 
                                      total: 0, 
                                      items: [] 
                                  });
                              }
                              const group = extractoFechaGroups.get(groupKey);
                              group.total += monto;
                              group.items.push({ row, index });
                          }
                      }
                  }
              });
              
              // console.log(`[PASO 5 F2] Grupos de extracto creados: ${extractoFechaGroups.size}`);
              
              // Comparar grupos del extracto con grupos de VISA
              extractoFechaGroups.forEach((grupoExtracto, groupKey) => {
                  const { fechaKey, codcomKey } = grupoExtracto;
                  
                  if (visaCommerceMap.has(codcomKey)) {
                      const gruposVisa = visaCommerceMap.get(codcomKey);
                      
                      // Buscar grupo VISA con el mismo monto total (fechas pueden ser diferentes)
                      const matchIndex = gruposVisa.findIndex(grupoVisa => {
                          const visaFechaKey = createDateKey(grupoVisa.fechaProceso);
                          const montoMatch = Math.abs(grupoExtracto.total - grupoVisa.total) < 0.01;
                          // console.log(`[PASO 5 F2] Comparando: Extracto ${fechaKey}:${grupoExtracto.total} vs VISA ${visaFechaKey}:${grupoVisa.total} = ${montoMatch}`);
                          return montoMatch; // Solo por monto, no por fecha
                      });
                      
                      if (matchIndex !== -1) {
                          const grupoVisa = gruposVisa[matchIndex];
                          
                          const visaFechaKey = createDateKey(grupoVisa.fechaProceso);
                          
                          // Marcar todos los registros del extracto como conciliados F2
                          grupoExtracto.items.forEach(item => {
                              const opNum = item.row[opNumExtractoIndex];
                              item.row[item.row.length - 2] = 'P5-F2-Conciliado';
                              item.row[item.row.length - 1] = `VISA-${codcomKey} - Monto: ${grupoExtracto.total} (${fechaKey}‚Üí${visaFechaKey})`;
                          });
                          
                          // Marcar todos los registros VISA del grupo como conciliados F2
                          grupoVisa.items.forEach(item => {
                              const firstOpNum = grupoExtracto.items[0].row[opNumExtractoIndex];
                              item.row[item.row.length - 2] = 'P5-F2-Conciliado';
                              item.row[item.row.length - 1] = `${firstOpNum} - Monto: ${grupoExtracto.total} (${fechaKey}‚Üí${visaFechaKey})`;
                          });
                          
                          // Remover el grupo VISA usado
                          gruposVisa.splice(matchIndex, 1);
                          if (gruposVisa.length === 0) {
                              visaCommerceMap.delete(codcomKey);
                          }
                          
                          conciliadosVisaF2++;
                          // console.log(`[PASO 5 F2] ‚úÖ CONCILIADO: Comercio ${codcomKey} - Monto: ${grupoExtracto.total} - Extracto(${fechaKey}) vs VISA(${visaFechaKey})`);
                      }
                  }
              });
              
              conciliadosVisa = conciliadosVisaF1 + conciliadosVisaF2;
              // console.log(`[PASO 5] RESUMEN: F1=${conciliadosVisaF1}, F2=${conciliadosVisaF2}, Total=${conciliadosVisa} conciliaciones VISA`);
          }

          // PASO 6: Conciliaci√≥n PAYU
          let conciliadosPayu = 0;
          if (payuMap.size > 0) {
              // console.log('\nüí∞ PASO 6: Conciliando con PAYU');
              dataExtractoConEstado.forEach((row, index) => {
                  if (row[row.length - 2] !== 'Pendiente') return; // Ya conciliado

                  const fechaRaw = row[fechaExtractoIndex];
                  const montoRaw = row[montoExtractoIndex];
                  
                  const fecha = parseDate(fechaRaw);
                  let fechaKey = null;
                  if (fecha) {
                      const year = fecha.getUTCFullYear();
                      const month = String(fecha.getUTCMonth() + 1).padStart(2, '0');
                      const day = String(fecha.getUTCDate()).padStart(2, '0');
                      fechaKey = `${year}-${month}-${day}`;
                  }
                  
                  const monto = convertToNumber(montoRaw);
                  
                  if (fechaKey && !isNaN(monto)) {
                      const key = `${fechaKey}_${monto.toFixed(2)}`;
                      
                      if (payuMap.has(key)) {
                          const matches = payuMap.get(key);
                          if (matches.length > 0) {
                              const matchData = matches.shift();
                              const matchRow = matchData.row;
                              
                              const debitos = matchRow[payuHeaders.indexOf('DEBITOS')];
                              const opNum = row[opNumExtractoIndex];
                              const fechaStr = fecha.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
                              
                              // Marcar como conciliado con prefijo P6
                              row[row.length - 2] = 'P6 - CONCILIADO';
                              row[row.length - 1] = `PAYU - ${fechaStr}`;
                              matchRow[matchRow.length - 2] = 'P6 - CONCILIADO';
                              matchRow[matchRow.length - 1] = `${opNum} - ${fechaStr}`;
                              
                              conciliadosPayu++;
                              // console.log(`[EXTRACTO ${index}] ‚úÖ P6 - CONCILIADO con PAYU d√©bitos ${debitos}`);
                              
                              if (matches.length === 0) payuMap.delete(key);
                          }
                      }
                  }
              });
          }

          // console.log(`\n=== RESUMEN DE CONCILIACI√ìN ===`);
          // console.log(`P2-F2 - AMEX (fecha+monto): ${conciliadosAmexF2} conciliaciones`);
          // console.log(`P2-F3 - AMEX (solo monto): ${conciliadosAmexF3} conciliaciones`);
          // console.log(`P2 - AMEX Total: ${conciliadosAmex} conciliaciones`);
          // console.log(`P3 - DINERS: ${conciliadosDiners} conciliaciones`);
          // console.log(`P4 - MC: ${conciliadosMc} conciliaciones`);
          // console.log(`P5 - VISA: ${conciliadosVisa} conciliaciones`);
          // console.log(`P6 - PAYU: ${conciliadosPayu} conciliaciones`);
          
          const totalPendientes = dataExtractoConEstado.filter(row => row[row.length - 2] === 'Pendiente').length;
          // console.log(`PENDIENTES: ${totalPendientes} registros`);

          return {
              conciliadoExtracto: [finalExtractoHeaders, ...dataExtractoConEstado],
              conciliadoAmex: finalAmexHeaders.length > 0 ? [finalAmexHeaders, ...dataAmexConEstado] : [],
              conciliadoDiners: finalDinersHeaders.length > 0 ? [finalDinersHeaders, ...datadinersConEstado] : [],
              conciliadoMc: finalMcHeaders.length > 0 ? [finalMcHeaders, ...datamcConEstado] : [],
              conciliadoVisa: finalVisaHeaders.length > 0 ? [finalVisaHeaders, ...datavisaConEstado] : [],
              conciliadoPayu: finalPayuHeaders.length > 0 ? [finalPayuHeaders, ...datapayuConEstado] : []
          };
      }

      async function readFileAndGetData(file, options) {
          return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = function(e) {
                  try {
                      const data = new Uint8Array(e.target.result);
                      const workbook = XLSX.read(data, { type: 'array' });
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];
                      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });

                      if (!jsonData || jsonData.length === 0) throw new Error(`El archivo ${file.name} est√° vac√≠o.`);
                      
                      const headerRowIndex = options.headerRow ? options.headerRow - 1 : 0;
                      if (jsonData.length <= headerRowIndex) throw new Error(`El archivo ${file.name} no tiene una fila de encabezado en la posici√≥n ${options.headerRow || 1}.`);
                      
                      const headers = jsonData[headerRowIndex].map(h => String(h || '').trim());
                      const upperHeaders = headers.map(h => h.toUpperCase());

                      const missingHeaders = options.requiredHeaders.filter(h => !upperHeaders.includes(h.toUpperCase()));
                      if (missingHeaders.length > 0) {
                          throw new Error(`Al archivo ${file.name} le faltan las columnas: ${missingHeaders.join(', ')}`);
                      }

                      // Devolver headers (con casing original) y el resto de los datos
                      resolve([headers, ...jsonData.slice(headerRowIndex + 1)]);

                  } catch (error) {
                      reject(error);
                  }
              };
              reader.onerror = (error) => reject(new Error(`No se pudo leer el archivo ${file.name}`));
              reader.readAsArrayBuffer(file);
          });
      }

      function convertToNumber(value) {
          if (!value || value === null || value === undefined) {
              return NaN;
          }
          
          if (typeof value === 'number') {
              // console.log(`[convertToNumber] Valor ya es num√©rico: ${value}`);
              return value;
          }
          
          if (typeof value === 'string') {
              if (value.trim() === '') {
                  return NaN;
              }
              // Maneja formatos como "1.190,07" (remueve puntos, reemplaza coma) o "1190.07"
              const cleanValue = value.replace(/\./g, '').replace(',', '.');
              const num = parseFloat(cleanValue);
              // console.log(`[convertToNumber] String "${value}" -> Limpio "${cleanValue}" -> N√∫mero ${num}`);
              return num;
          }
          console.warn(`[convertToNumber] Fall√≥ la conversi√≥n para el valor:`, value);
          return NaN;
      }

      function parseDate(value) {
          // 1. Validaciones iniciales
          if (value === null || value === undefined) return null;
          if (value instanceof Date && !isNaN(value)) return value;
          
          const strValue = String(value).trim();
          if (strValue === '') return null;

          // 2. Formato ISO: yyyy-mm-dd
          if (strValue.includes('-') && strValue.length === 10) {
              const parts = strValue.split('-');
              if (parts.length === 3) {
                  const year = parseInt(parts[0], 10);
                  const month = parseInt(parts[1], 10) - 1;
                  const day = parseInt(parts[2], 10);
                  if (!isNaN(day) && !isNaN(month) && !isNaN(year) && year > 1900) {
                      const date = new Date(year, month, day);
                      // console.log(`[parseDate] ISO "${value}" (yyyy-mm-dd) ->`, date.toString());
                      return date;
                  }
              }
          }

          // 3. Formato de texto: dd/mm/aaaa
          if (strValue.includes('/')) {
              const parts = strValue.split('/');
              if (parts.length === 3) {
                  const day = parseInt(parts[0], 10);
                  const month = parseInt(parts[1], 10) - 1;
                  const year = parseInt(parts[2], 10);
                  if (!isNaN(day) && !isNaN(month) && !isNaN(year) && year > 1900) {
                      const date = new Date(year, month, day);
                      // console.log(`[parseDate] String "${value}" (dd/mm/aaaa) ->`, date.toString());
                      return date;
                  }
              }
          }

          // 4. Formatos num√©ricos (como string o number)
          if (!isNaN(strValue)) {
              // A. N√∫mero de serie de Excel (son valores relativamente bajos)
              const numValue = Number(value);
              if (numValue > 0 && numValue < 100000) {
                  const utc_days = Math.floor(numValue - 25569);
                  const utc_value = utc_days * 86400;
                  const date_info = new Date(utc_value * 1000);
                  const date = new Date(date_info.getTime() + (date_info.getTimezoneOffset() * 60 * 1000));
                  // console.log(`[parseDate] Serial Excel "${value}" ->`, date.toUTCString());
                  return date;
              }

              // B. Formato VISA (dmmaaaa o ddmmaaaa)
              let visaStr = strValue;
              if (visaStr.length === 7) visaStr = '0' + visaStr;
              if (visaStr.length === 8) {
                  const day = parseInt(visaStr.substring(0, 2), 10);
                  const month = parseInt(visaStr.substring(2, 4), 10);
                  const year = parseInt(visaStr.substring(4, 8), 10);
                  if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year > 1900) {
                      const date = new Date(year, month - 1, day);
                      // console.log(`[parseDate] VISA-like "${value}" (ddmmaaaa) ->`, date.toString());
                      return date;
                  }
              }
              
              // C. Formato AMEX (aaaammdd)
              if (strValue.length === 8) {
                  const year = parseInt(strValue.substring(0, 4), 10);
                  const month = parseInt(strValue.substring(4, 6), 10);
                  const day = parseInt(strValue.substring(6, 8), 10);
                  if (year > 1900 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                      const date = new Date(year, month - 1, day);
                      // console.log(`[parseDate] AMEX-like "${value}" (aaaammdd) ->`, date.toString());
                      return date;
                  }
              }
          }

          console.warn(`[parseDate] Fall√≥ el parseo para el valor:`, value);
          return null;
      }

      function generateAndDownloadExcel() {
        if (processedData.extracto.length === 0) {
            addBotMessage('‚ùå No hay datos procesados para exportar.');
            return;
        }
        
        const workbook = XLSX.utils.book_new();
        
        // Hoja EXTRACTO (siempre presente)
        const extractoWorksheet = XLSX.utils.aoa_to_sheet(processedData.extracto);
        XLSX.utils.book_append_sheet(workbook, extractoWorksheet, 'EXTRACTO');
        
        // Hoja AMEX (si hay datos)
        if (processedData.amex.length > 0) {
            const amexWorksheet = XLSX.utils.aoa_to_sheet(processedData.amex);
            XLSX.utils.book_append_sheet(workbook, amexWorksheet, 'AMEX');
        }
        
        // Hoja DINERS (si hay datos)
        if (processedData.diners.length > 0) {
            const dinersWorksheet = XLSX.utils.aoa_to_sheet(processedData.diners);
            XLSX.utils.book_append_sheet(workbook, dinersWorksheet, 'DINERS');
        }

        // Hoja MC (si hay datos)
        if (processedData.mc.length > 0) {
            const mcWorksheet = XLSX.utils.aoa_to_sheet(processedData.mc);
            XLSX.utils.book_append_sheet(workbook, mcWorksheet, 'MC');
        }

        // Hoja VISA (si hay datos)
        if (processedData.visa.length > 0) {
            const visaWorksheet = XLSX.utils.aoa_to_sheet(processedData.visa);
            XLSX.utils.book_append_sheet(workbook, visaWorksheet, 'VISA');
        }

        // Hoja PAYU (si hay datos)
        if (processedData.payu.length > 0) {
            const payuWorksheet = XLSX.utils.aoa_to_sheet(processedData.payu);
            XLSX.utils.book_append_sheet(workbook, payuWorksheet, 'PAYU');
        }

        const fileName = `CONCILIACION_${selectedCurrency}_${new Date().toISOString().slice(0, 10)}.xlsx`;
        XLSX.writeFile(workbook, fileName);
        addBotMessage('‚úÖ Excel de conciliaci√≥n generado. La descarga deber√≠a comenzar en breve.');
      }
    });
  </script>
</body>
</html>